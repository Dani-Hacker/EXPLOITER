from discord.ext import commands,tasks
from discord.ext.commands import cooldown, BucketType
import discord
import googletrans
from mongodbs import *
# import translator
from googletrans import Translator
# import datetime
import pytz
import asyncio
from random import randint
from datetime import  timedelta,datetime

class Others(commands.Cog, name='other'):

    def __init__(self, bot):
        self.bot = bot
        self.determine_task.start()

    def cog_load(self):
      print("Other was loaded")

    def cog_unload(self):
      self.determine_task.cancel()
      print(f'Other was unloaded')

    @commands.command(aliases=["channel_stats", "channel_health", "channel_info", "channel_information"])
    @commands.cooldown(1, 30, commands.BucketType.user)
    async def channel_status(self, ctx, n,channel: discord.TextChannel = None):
      
        serverId = ctx.message.guild.id    
        if user_info.find_one({'id': serverId}):
            try:
              x=list(user_info.find({ "id":serverId }))[0]['disabled']
              if "channel_status" in x:
                return
            except:
              pass
        try:
          n=int(n)
        except:
          await ctx.reply("Only integer can be allowed")
          return

        if(not isinstance(n, int)):
            await ctx.reply("Only integer can be allowed")
            return
        elif(n<1 or n>30):
          await ctx.reply("Only days can be below 30")  
          return  
        n=int(n)  
        if not channel:
            channel = ctx.channel
        embed_i=discord.Embed(title="⌛⌛⌛Gathering messages...This may take some time.It will be edited once updated ⌛⌛⌛",colour=randint(0, 0xffffff))    
        initial=await ctx.reply(embed=embed_i)
  
        async with ctx.channel.typing():
          count = 0
          async for message in channel.history(limit=500000, after=datetime.today() - timedelta(days=n)): count += 1
          member_count=int(ctx.guild.member_count)
          if count >= 5000:
              average = "OVER 5000!"
              healthiness = "VERY HEALTHY"
          
          else:
              try:
                  average = round(count / n, 2)

                  if 0 > member_count / average: healthiness = "VERY HEALTHY"
                  elif member_count / average <= 5: healthiness = "HEALTHY"
                  elif member_count / average <= 10: healthiness = "NORMAL"
                  elif member_count / average <= 20: healthiness = "UNHEALTHY"
                  else: healthiness = "VERY UNHEALTHY"

              except ZeroDivisionError:
                  average = 0
                  healthiness = "VERY UNHEALTHY"
        embed = discord.Embed(title="Channel Information",description=f"Total number of members {member_count}",timestamp=ctx.message.created_at,colour=randint(0, 0xffffff))
        embed.set_footer(text=self.bot.user.name, icon_url=self.bot.user.avatar_url)
        embed.add_field(name=f"Total number of messages in {channel} channel in past-{n} days­", value=f"{count}", inline=False)
        embed.add_field(name=f"­Average number of messages in {channel}  channel", value=f'{average}', inline=False)
        embed.add_field(name="Channel health", value=f"{healthiness}", inline=False)
        embed.set_thumbnail(url=ctx.guild.icon_url)
        embed.set_author(name=ctx.author.name, icon_url=ctx.author.avatar_url)

        await initial.edit(embed=embed)


    @commands.command(aliases=['translate'])
    @commands.cooldown(1, 2, commands.BucketType.user)
    async def tran(self,ctx,lang,*,args):
      serverId = ctx.message.guild.id    
      if server_info.find_one({'id': serverId}):
        try:
          x=list(server_info.find({ "id":serverId }))[0]['disabled']
          if "tran" in x:
            return
        except:
          pass
      try:
        t=Translator()
        a=t.translate(args,dest=lang)
        if(args==a.text):
          msgID=int(args)
          msg = await ctx.fetch_message(msgID)
          a=t.translate(msg.content,dest=lang)
          await ctx.reply(a.text)
        else:  
          await ctx.reply(a.text)
      except:
        await ctx.reply("Can't translate this!")   
		
    @tasks.loop(seconds=60)
    async def determine_task(self):
      IST = pytz.timezone('Asia/Kolkata')
      time_now=(datetime.now(IST))
      time_now=time_now.strftime('%Y-%m-%d %H:%M:%S')
      all_records=task_info.find()
      for i in all_records:
        if(time_now>=i['date']):
          channel_id=i['id']
          channel=self.bot.get_channel(channel_id)
          task=i['task']
          author=i['author']
          ping=i['ping']
          embed=discord.Embed(title="**⏰⏰Reminder⏰⏰**",description=f"**Requested by {author}**",colour=randint(0, 0xffffff))
          embed.add_field(name="Task",value=f"{task}",inline=False)
          await channel.send(embed=embed)
          await channel.send(f"Don't forget to do the task {ping}")
          task_info.delete_one({"date":i['date']})  


    @determine_task.before_loop
    async def before_start(self):
        await self.bot.wait_until_ready()


    @commands.command(aliases=['png'])
    @commands.cooldown(1, 5, commands.BucketType.user)
    async def ping(self,ctx):
      serverId = ctx.message.guild.id    
      if server_info.find_one({'id': serverId}):
        try:
          x=list(server_info.find({ "id":serverId }))[0]['disabled']
          if "ping" in x:
            return
        except:
          pass
      await ctx.send(f'Pong! In {round(self.bot.latency * 1000)} ms')
    


    @commands.command(name="remember",aliases=['rem','rember'])
    @commands.cooldown(1, 5, commands.BucketType.user)
    @commands.guild_only()
    async def remember(self,ctx):
      serverId = ctx.message.guild.id    
      if server_info.find_one({'id': serverId}):
        try:
          x=list(server_info.find({ "id":serverId }))[0]['disabled']
          if "remember" in x:
            return
        except:
          pass
      channelId=ctx.channel.id
      author=ctx.author
      questions = ["Enter the date with time when i want you to remind the task. Example:``2021-11-09 23:50:41``","What is the task that i need to remind you at that day?","Ping the people whom i wanted to ping?"]
      answers = []
      def check_a(m):
        if(m.author == ctx.author and m.channel == ctx.channel):
          return True

      def check_valid_date(date_string:str):
        IST = pytz.timezone('Asia/Kolkata')
        time_now=(datetime.now(IST))
        time_now=time_now.strftime('%Y-%m-%d %H:%M:%S')
        format = "%Y-%m-%d %H:%M:%S"
        if(len(date_string)!=19):
          return False
        try:
          try:
            expect_time=str(datetime.strptime(date_string, format))
            if(time_now<expect_time):
                return True
            else:
                return False
          except:
            return False
        except:
          return False 

      for i in questions:
          await ctx.send(i)
          try:
              msg = await self.bot.wait_for('message', timeout=120.0, check=check_a)
          except asyncio.TimeoutError:
              await ctx.send("You didn't entered the task on time, please answer at next time!")
              return
          else:
              answers.append(msg.content)  
 
      y=str(answers[0])
      if not(check_valid_date(y)):
        await ctx.send("Enter it in %yyyy %mm %dd hh:mm:ss format. Note:``You can only schedule future tasks!!!``")
        return
      else:                            
        task_Doc = {
                      'date': str(answers[0])
                      ,'id':int(channelId),
                      'task':str(answers[1]),
                      "author":ctx.author.mention,
                      "ping":str(answers[2])
                  }
        task_info.insert_one(task_Doc)   
        await ctx.reply("I remembered that thing i will let you know on that time!!")  

    @commands.command()
    @commands.guild_only()
    @commands.cooldown(1, 4, commands.BucketType.user)
    async def send(self,ctx,*,args):
      serverId = ctx.message.guild.id    
      if server_info.find_one({'id': serverId}):
        try:
          x=list(server_info.find({ "id":serverId }))[0]['disabled']
          if "send" in x:
            return
        except:
          pass
      await ctx.message.delete()
      embed2 = discord.Embed(title=args,timestamp=ctx.message.created_at, colour=randint(0, 0xffffff))
      embed2.set_footer(text=ctx.author.name, icon_url=ctx.author.avatar_url)
      await ctx.send(embed=embed2)



    @commands.command()
    @commands.guild_only()
    @commands.cooldown(1, 5, commands.BucketType.user)
    async def serverinfo(self, ctx):
        serverId = ctx.message.guild.id    
        if server_info.find_one({'id': serverId}):
          try:
            x=list(server_info.find({ "id":serverId }))[0]['disabled']
            if "serverinfo" in x:
              return
          except:
            pass
        def boost(x:int):
          if(x<2):
            return "Free"
          elif(x>=2 and x<7):
            return "Friends"
          elif(x>=7 and x<14):
            return "Groups"  
          else:
            return "Communities" 
        def chunkify(lst,n):
          return [lst[i::n] for i in range(n)]    
        plan=boost(int(ctx.guild.premium_subscription_count))
        role_count = len(ctx.guild.roles)
        list_of_bots = [bot.mention for bot in ctx.guild.members if bot.bot]
            
        embed2 = discord.Embed(timestamp=ctx.message.created_at, colour=randint(0, 0xffffff))
        embed2.add_field(name='Name', value=f"{ctx.guild.name}", inline=False)
        embed2.add_field(name='Owner', value=f"{ctx.guild.owner.name}")
        embed2.add_field(name='Verification Level', value=str(ctx.guild.verification_level))
        embed2.add_field(name='Highest role', value=ctx.guild.roles[-1])
        n=len(ctx.guild.roles)
        splits=int(n/40)+1
        big_list=[]
        for i in ctx.guild.roles:
          big_list.append(i.mention)
        x=chunkify(big_list,splits)
        for i in range(splits):
          roles_list=""
          for j in x[i]:
            roles_list+=j+" "
          embed2.add_field(name="Roles",value=roles_list)
        embed2.add_field(name='Created At', value=ctx.guild.created_at.__format__('%A, %d. %B %Y @ %H:%M:%S'), inline=False)
        embed2.add_field(name='Joined', value=ctx.author.joined_at.__format__('%A, %d. %B %Y @ %H:%M:%S'),inline=False)
        embed2.add_field(name='Number of roles', value=str(role_count))
        embed2.add_field(name='Number Of Members', value=ctx.guild.member_count,inline=True)
        embed2.add_field(name='ServerId', value=ctx.guild.id,inline=True)
        embed2.add_field(name='Region', value=ctx.guild.region,inline=True)
        embed2.add_field(name="Boosts count",value=ctx.guild.premium_subscription_count)
        embed2.add_field(name="Server Plan",value=plan)
        total_text_channels = len(ctx.message.guild.text_channels)
        total_voice_channels = len(ctx.message.guild.voice_channels)
        total_category=len(ctx.message.guild.categories)
        total_channels = total_text_channels  + total_voice_channels 
        embed2.add_field(name="Server Total Channels: ", value=total_channels )
        embed2.add_field(name="Server Text Channels: ", value=total_text_channels )
        embed2.add_field(name="Server Voice Channels: ", value=total_voice_channels )
        embed2.add_field(name="Server Category: ", value=total_category ,inline=True)
        statuses = [len(list(filter(lambda m: str(m.status) == "online", ctx.guild.members))),
					len(list(filter(lambda m: str(m.status) == "idle", ctx.guild.members))),
					len(list(filter(lambda m: str(m.status) == "dnd", ctx.guild.members))),
					len(list(filter(lambda m: str(m.status) == "offline", ctx.guild.members))),("\u200b", "\u200b", True)]
        fields=[("Humans", len(list(filter(lambda m: not m.bot, ctx.guild.members))), True),
        ("Bots", len(list(filter(lambda m: m.bot, ctx.guild.members))), True),
        ("Banned members", len(await ctx.guild.bans()), True),
        ("Statuses", f"🟢 {statuses[0]} 🟠 {statuses[1]} 🔴 {statuses[2]} ⚪ {statuses[3]}", True)]
        for name, value, inline in fields:
            embed2.add_field(name=name, value=value, inline=inline)
        embed2.add_field(name='Bots:', value=(', '.join(list_of_bots)),inline=False)
        embed2.set_thumbnail(url=ctx.guild.icon_url)
        embed2.set_author(name=ctx.author.name, icon_url=ctx.author.avatar_url)
        embed2.set_footer(text=self.bot.user.name, icon_url=self.bot.user.avatar_url)
        await ctx.send(embed=embed2)


           
    @commands.command(name="info",aliases=['whois'])
    @commands.guild_only()
    @commands.cooldown(1, 4, commands.BucketType.user)
    async def info(self,ctx, *, user: discord.Member = None): # b'\xfc'
        serverId = ctx.message.guild.id    
        if server_info.find_one({'id': serverId}):
          try:
            x=list(server_info.find({ "id":serverId }))[0]['disabled']
            if "info" in x:
              return
          except:
            pass
        def chunkify(lst,n):
          return [lst[i::n] for i in range(n)]
        if user is None:
            user = ctx.author      
        date_format = "%a, %d %b %Y %I:%M %p"
        embed = discord.Embed(colour=randint(0, 0xffffff), description=user.mention)
        embed.set_author(name=str(user), icon_url=user.avatar_url)
        embed.set_thumbnail(url=user.avatar_url)
        embed.add_field(name="Joined", value=user.joined_at.strftime(date_format))
        members = sorted(ctx.guild.members, key=lambda m: m.joined_at)
        embed.add_field(name="Join position", value=str(members.index(user)+1))
        person =  self.bot.get_user(user.id)

        embed.add_field(name="Account Created at", value=person.created_at.strftime(date_format))
        n=len(user.roles)
        embed.add_field(name="Number of roles",value=n,inline=False)
        if len(user.roles) > 1:
            splits=int(n/40)+1
            big_list=[]
            for i in user.roles:
              big_list.append(i.mention)
            x=chunkify(big_list,splits)
            for i in range(splits):
              roles_list=""
              for j in x[i]:
                roles_list+=j+" "
              embed.add_field(name=f"Roles:",value=roles_list)

        perm_string = ', '.join([str(p[0]).replace("_", " ").title() for p in user.guild_permissions if p[1]])
        embed.add_field(name="Guild permissions", value=perm_string, inline=False)
        # list_roles=""
        badge_class = str(user.public_flags.all()).replace('[<UserFlags.', '').replace('>]', '').replace('_',
                                                                                                         ' ').replace(
        ':', '').title()
        badge_class = ''.join([i for i in badge_class if not i.isdigit()])
        embed.add_field(name="Badges",value=badge_class,inline=False)
        fields=[("Bot?", user.bot, True), ("Top role", user.top_role.mention, True),
				  ("Status", str(user.status).title(), True),
          ("Boosted", bool(user.premium_since), True)]
        for name, value, inline in fields:
			      embed.add_field(name=name, value=value, inline=inline)  
        embed.set_footer(text='ID: ' + str(user.id))

        for activity in user.activities:
            if isinstance(activity, discord.Game):
                name = activity.name
                Types = "Playing"
                Activity = f"{name}"
            elif isinstance(activity, discord.Streaming):
                name2 = activity.name
                name3 = activity.platform
                Types = "Streaming"
                Activity = f"{name2} on {name3}"
            elif isinstance(activity, discord.Spotify):
                name4 = activity.title
                name5 = activity.artists
                Types = "Listening to Spotify"
                Activity = f"**Song Name**:{name4}\n**Song Artists:**{name5}"
            elif isinstance(activity, discord.CustomActivity):
                name6 = activity.name
                Types = "Custom Status"
                Activity = f"{name6}"
            else:
                name7 = activity.name
                Types =  "Playing"
                Activity = f"{name7}"
            embed.add_field(name=f"Activity",value=f"{Types}:\n{Activity}")
        return await ctx.send(embed=embed)      


def setup(bot):
    # asyncio.sleep(1)
    bot.add_cog(Others(bot))
    print(f'Other was loaded!')        