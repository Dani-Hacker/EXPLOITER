import discord
from discord.ext import commands
from pymongo.read_preferences import Secondary
from pymongo.topology import process_events_queue
from troops import *
from mongodb import *
import random
import asyncio
import os
import time
import requests
from discord.utils import get
from dotenv import load_dotenv
import datetime
from mongodb import *
from troops import *
import akinator
from akinator.async_aki import Akinator
import DiscordUtils
import youtube_dl

beg = True
load_dotenv()  # take env variable from dot env
TOKEN = os.getenv("TOKEN")
# bot.load_extension('dch')


# initialization
intents = discord.Intents.all()
intents.members = True

bot = commands.Bot(command_prefix="?", intents=intents)

bot.remove_command("help")
music = DiscordUtils.Music()
# start


aki = Akinator()
emojis_c = ['‚úÖ', '‚ùå', 'ü§∑', 'üëç', 'üëé', '‚èÆ', 'üõë']
emojis_w = ['‚úÖ', '‚ùå']


@bot.event
async def on_ready():
    await bot.change_presence(status=discord.Status.idle, activity=discord.Game('?help'))
    print(f"Logged in as {bot.user}")
    # bot.load_extension('dch')


def w(name, desc, picture):
    embed_win = discord.Embed(title=f"It's {name} ({desc})! Was I correct?",
                              colour=0x00FF00)
    embed_win.set_image(url=picture)
    return embed_win


@bot.event
async def on_command_error(ctx, error):
    if isinstance(error, commands.MissingRequiredArgument):
        title_error_one = 'You have not entered anything after the command'
        desc_error_one = 'Use **?help** to see a list of all the commands available'
        embed_var_one = discord.Embed(title=title_error_one,
                                      description=desc_error_one,
                                      color=0xFF0000)
        await ctx.reply(embed=embed_var_one)
    if isinstance(error, commands.CommandNotFound):
        title_error_two = 'The command you have entered does not exist'
        desc_error_two = 'Use **?help** to see a list of all the commands available'
        embed_var_two = discord.Embed(title=title_error_two,
                                      description=desc_error_two,
                                      color=0xFF0000)
        await ctx.reply(embed=embed_var_two)
    if isinstance(error, commands.MaxConcurrencyReached):
        title_error_four = 'Someone is already playing'
        desc_error_four = 'Please wait until the person currently playing is done with their turn'
        embed_var_four = discord.Embed(title=title_error_four,
                                       description=desc_error_four,
                                       color=0xFF0000)
        await ctx.reply(embed=embed_var_four)


@bot.command(name="caki")
@commands.has_permissions(administrator=True)
async def caki(ctx, answers):
    try:
        c_id = int(answers[2:-1])
        channel = bot.get_channel(c_id)
        serverId = ctx.message.guild.id
        if server_info.find_one({'id': serverId}):
            server_info.update_one({'id': serverId}, {
                '$set': {'caki': c_id}})
            await ctx.send(f"You fixed {channel} as akinator channel")
        else:
            server_Doc = {
                'id': int(serverId), 'caki': c_id
            }
            server_info.insert_one(server_Doc)
            await ctx.send(f"You fixed {channel} as akinator channel")
    except:
        # await ctx.reply("You can send ephemeral messages too!", flags = MessageFlags().EPHEMERAL)
        await ctx.reply("Enter a proper channel")


@bot.command(name='aki')
@commands.max_concurrency(1, wait=False)
async def aki(ctx, *, extra):
    try:
        serverId = ctx.message.guild.id
        channel_id = str(server_info.find_one(
            {'id': serverId})['caki'])
        channel_id = int(channel_id)
    except:
        await ctx.send("Ask admin to set a channel for akinator by using ``?caki`` command!")
        return
    if ctx.channel.id == channel_id:
        desc_loss = ''
        d_loss = ''
        aki = Akinator()

        def check_c(reaction, user):
            return user == ctx.author and str(reaction.emoji) in emojis_c

        def check_w(reaction, user):
            return user == ctx.author and str(reaction.emoji) in emojis_w

        async with ctx.typing():
            if extra == 'people':
                q = await aki.start_game(child_mode=True)
            elif extra == 'objects' or extra == 'animals':
                q = await aki.start_game(language=f'en_{extra}',
                                         child_mode=True)
            else:
                title_error_three = 'This game mode does not exist'
                desc_error_three = 'Use **.help** to see a list of all the game modes available'
                embed_var_three = discord.Embed(title=title_error_three,
                                                description=desc_error_three,
                                                color=0xFF0000)
                await ctx.reply(embed=embed_var_three)
                return

            embed_question = discord.Embed(
                title='Tip : Wait until all emojis finish being added before reacting'
                ' or you will have to unreact and react again',
                color=0x00FF00)
            msg = await ctx.reply(embed=embed_question)
            await asyncio.sleep(3)
            x = 0
        while aki.progression <= 85:
            message = await ctx.fetch_message(msg.id)
            embed_question1 = discord.Embed(
                title=f"{q}",
                color=0x00FF00)
            await message.edit(embed=embed_question1)
            if(x == 0):
                for m in emojis_c:
                    await message.add_reaction(m)
            x = x+1
            try:
                symbol, username = await bot.wait_for('reaction_add', timeout=45.0, check=check_c)
            except asyncio.TimeoutError:
                embed_game_ended = discord.Embed(
                    title='You took too long,the game has ended',
                    color=0xFF0000)
                await message.edit(embed=embed_game_ended)
                return

            if str(symbol) == emojis_c[0]:
                a = 'y'
                await message.remove_reaction(emojis_c[0], ctx.author)
            elif str(symbol) == emojis_c[1]:
                a = 'n'
                await message.remove_reaction(emojis_c[1], ctx.author)
            elif str(symbol) == emojis_c[2]:
                a = 'idk'
                await message.remove_reaction(emojis_c[2], ctx.author)
            elif str(symbol) == emojis_c[3]:
                a = 'p'
                await message.remove_reaction(emojis_c[3], ctx.author)
            elif str(symbol) == emojis_c[4]:
                a = 'pn'
                await message.remove_reaction(emojis_c[4], ctx.author)
            elif str(symbol) == emojis_c[5]:
                a = 'b'
                await message.remove_reaction(emojis_c[5], ctx.author)
            elif str(symbol) == emojis_c[6]:
                await message.remove_reaction(emojis_c[6], ctx.author)
                embed_game_end = discord.Embed(
                    title='I ended the game because you asked me to do it',
                    color=0x00FF00)
                await message.edit(embed=embed_game_end)
                return

            if a == "b":
                try:
                    q = await aki.back()
                except akinator.CantGoBackAnyFurther:
                    pass
            else:
                q = await aki.answer(a)

        await aki.win()

        wm = await ctx.reply(
            embed=w(aki.first_guess['name'], aki.first_guess['description'],
                    aki.first_guess['absolute_picture_path']))

        for e in emojis_w:
            await wm.add_reaction(e)

        try:
            s, u = await bot.wait_for('reaction_add',
                                      timeout=30.0,
                                      check=check_w)
        except asyncio.TimeoutError:
            for times in aki.guesses:
                d_loss = d_loss + times['name'] + '\n'
            t_loss = 'Here is a list of all the people I had in mind :'
            embed_loss = discord.Embed(title=t_loss,
                                       description=d_loss,
                                       color=0xFF0000)
            await ctx.reply(embed=embed_loss)
            return

        if str(s) == emojis_w[0]:
            embed_win = discord.Embed(
                title='Great, guessed right one more time!', color=0x00FF00)
            await ctx.reply(embed=embed_win)
        elif str(s) == emojis_w[1]:
            for times in aki.guesses:
                desc_loss = desc_loss + times['name'] + '\n'
            title_loss = 'No problem, I will win next time! But here is a list of all the people I had in mind :'
            embed_loss = discord.Embed(title=title_loss,
                                       description=desc_loss,
                                       color=0xFF0000)
            await ctx.reply(embed=embed_loss)
    else:
        right_channel = bot.get_channel(channel_id)
        channel_mention = right_channel.mention
        wrong_channel = discord.Embed(
            title='You can only play in the following channel ' +
                  channel_mention,
            color=0xFF0000)
        await ctx.reply(embed=wrong_channel)


@bot.command()
async def join(ctx):
    if(ctx.author.voice == None):
        await ctx.reply("Join a voice channel first to use the commands")
        return
    try:
        await ctx.author.voice.channel.connect()  # Joins author's voice channel
    except:
        await ctx.reply("Already joined voice channel")


@bot.command()
async def leave(ctx):
    if(ctx.author.voice == None):
        await ctx.reply("Join a voice channel first to use the commands")
        return
    try:
        await ctx.voice_client.disconnect()
    except:
        await ctx.reply("Join a voice channel first to use the commands")


@bot.command()
async def play(ctx, *, url):
    try:
        if(ctx.author.voice == None):
            await ctx.reply("Join a voice channel first to use the commands")
            return
        player = music.get_player(guild_id=ctx.guild.id)
        if not player:
            player = music.create_player(ctx, ffmpeg_error_betterfix=True)
        if not ctx.voice_client.is_playing():
            await player.queue(url, search=True)
            song = await player.play()
            await ctx.send(f"Playing {song.name}")
        else:
            song = await player.queue(url, search=True)
            await ctx.send(f"Queued {song.name}")
    except:
        await ctx.reply('Try again later!!!')


@bot.command()
async def pause(ctx):
    try:
        if(ctx.author.voice == None):
            await ctx.reply("Join a voice channel first to use the commands")
            return
        player = music.get_player(guild_id=ctx.guild.id)
        song = await player.pause()
        await ctx.send(f"Paused {song.name}")
    except:
        await ctx.reply('You did not played a song!!!.Use ``?resume`` to resume the song!!!')


@bot.command()
async def resume(ctx):
    try:
        if(ctx.author.voice == None):
            await ctx.reply("Join a voice channel first to use the commands")
            return
        player = music.get_player(guild_id=ctx.guild.id)
        song = await player.resume()
        await ctx.send(f"Resumed {song.name}")
    except:
        await ctx.reply('You did not played a song!!!.Use ``?pause`` to pause the song!!!')


@bot.command()
async def stop(ctx):
    try:
        if(ctx.author.voice == None):
            await ctx.reply("Join a voice channel first to use the commands")
            return
        player = music.get_player(guild_id=ctx.guild.id)
        await player.stop()
        await ctx.send(f"Stopped the playing song")
    except:
        await ctx.reply('Play a song first!!!')


@bot.command()
async def loop(ctx):
    try:
        if(ctx.author.voice == None):
            await ctx.reply("Join a voice channel first to use the commands")
            return
        player = music.get_player(guild_id=ctx.guild.id)
        song = await player.toggle_song_loop()
        if song.is_looping:
            await ctx.send(f"Enabled loop for {song.name}")
        else:
            await ctx.send(f"Disabled loop for {song.name}")
    except:
        await ctx.reply('Play a song first!!!')


@bot.command()
async def queue(ctx):
    try:
        if(ctx.author.voice == None):
            await ctx.reply("Join a voice channel first to use the commands")
            return
        player = music.get_player(guild_id=ctx.guild.id)
        await ctx.send(f"{', '.join([song.name for song in player.current_queue()])}")
    except:
        await ctx.reply('Play a song first!!!')


@bot.command()
async def np(ctx):
    try:
        if(ctx.author.voice == None):
            await ctx.reply("Join a voice channel first to use the commands")
            return
        player = music.get_player(guild_id=ctx.guild.id)
        song = player.now_playing()
        await ctx.send(song.name)
    except:
        await ctx.reply('Not playing any song now!!!')


@bot.command()
async def skip(ctx):
    try:
        if(ctx.author.voice == None):
            await ctx.reply("Join a voice channel first to use the commands")
            return
        player = music.get_player(guild_id=ctx.guild.id)
        data = await player.skip(force=True)
        if len(data) == 2:
            await ctx.send(f"Skipped from {data[0].name} to {data[1].name}")
        else:
            await ctx.send(f"Skipped {data[0].name}")
    except:
        await ctx.reply('No other song in the queue!!!')


@bot.command()
async def volume(ctx, vol):
    try:
        if(ctx.author.voice == None):
            await ctx.reply("Join a voice channel first to use the commands")
            return
        vol = float(vol)
        if(vol < 0 or vol > 200):
            await ctx.reply("Volume available from ``0 to 200``")
            return
        player = music.get_player(guild_id=ctx.guild.id)
        # volume should be a float between 0 to 1
        song, volume = await player.change_volume(float(vol) / 100)
        await ctx.send(f"Changed volume for {song.name} to {volume*100}%")
    except:
        await ctx.reply('Play a song first!!!')


@bot.command()
async def remove(ctx, index):
    try:
        if(ctx.author.voice == None):
            await ctx.reply("Join a voice channel first to use the commands")
            return
        player = music.get_player(guild_id=ctx.guild.id)
        song = await player.remove_from_queue(int(index))
        await ctx.send(f"Removed {song.name} from queue")
    except:
        await ctx.reply(f'No song is there in the {index} to remove!!!')


# @bot.event
# async def on_member_remove(member):
#   try:
#     guild = bot.get_guild(898957956073263155)                        #server id
#     channel = guild.get_channel(898957956073263158)                     #channel id
#     await channel.send(f'{member.mention} left the server!  ')
#   except:
#     return


@bot.command(name="start")
async def start(ctx: commands.Context):
    ''' Use this command to start using the bot'''
    if user_info.find_one({'id': ctx.author.id}):  # checks user already started the game
        await ctx.reply('You have already started! For more commands use `?help`')
    else:       # if user hasn't started, adds the user to db
        x = time.time()
        userDoc = {
            'id': int(ctx.author.id),
            'name': str(ctx.author),
            'might': 0,
            't1': 0,
            't2': 0,
            't3': 0,
            'potions': 0
        }
        time_Doc = {
            'id': int(ctx.author.id), 'beg_time': x, 'resources_time': x, 'fight_time': x, 'scout_time': x, 'profile_time': x, 'potion_time': x, 'train_time': x, 'train_cost_time': x
        }
        user_info.insert_one(userDoc)
        user_time_info.insert_one(time_Doc)
        await ctx.reply(f'Hello! Welcome {ctx.author}!. You can start using our bot in 20 seconds!')


@bot.command(name="train_cost")
@commands.guild_only()
async def train_cost(ctx):
    if user_info.find_one({'id': ctx.author.id}) == None:
        await ctx.send('Please start using `?start`!')
        return
    used = time.time()
    last_used = float(user_time_info.find_one(
        {'id': ctx.author.id})['train_cost_time'])
    if(used - last_used < 20):
        em = discord.Embed(title="You are on cool down!", description='You can use this command in '+str(
            20-int(used - last_used))+" seconds"+"\nDefault cooldown for this command is 20 seconds")
        await ctx.reply(embed=em)
        return
    else:
        last_used = time.time()
        user_time_info.update_one({'id': ctx.author.id}, {
            '$set': {'train_cost_time': last_used}})
        em = discord.Embed(
            title="Training Cost and might", description="Used to see the cost and might of each tier troops", color=ctx.author.color)
        em.add_field(
            name="Tier1:", value="Might: ``2``               Cost: ``1``", inline=False)
        em.add_field(
            name="Tier2:", value="Might: ``8``               Cost: ``8``", inline=False)
        em.add_field(
            name="Tier3:", value="Might: ``24``               Cost: ``20``", inline=False)
        await ctx.send(embed=em)


@bot.command(name="avatar")
async def avatar(ctx: commands.Context, member: discord.Member = None):
    if(member == None):
        await ctx.send(ctx.author.avatar_url)
    else:
        try:
            await ctx.send(member.avatar_url)
        except:
            await ctx.send("Mention someone properly!!!")


@bot.command(name="hack")
@commands.guild_only()
async def hack(ctx: commands.Context, member: discord.Member):
    if(member == ctx.author):
        await ctx.send(f"I thought not to hack you my friend {member.mention} !. Since you insisted i started hacking you!!!")
        await asyncio.sleep(2)
    if(member == bot.user):
        await ctx.send("I am the Hacker üé≠ who hacks everyone. You tried to mess with me so i started hacking your system now üíÄüíÄ‚åõ‚åõ")
        await asyncio.sleep(2)
        member = ctx.author
    my_msg = await ctx.send(f"Started hacking..... {member.mention}")
    x = random.randint(0, 1000)
    texts = ["Collecting sensitive information ‚ö†Ô∏è from phishing once done on you... ",
             "Launching Malware ‚ò£Ô∏è attacks on you !!",
             "Injecting ransware and pegasus in your system üëæüëæ üëæ ",
             "Encrypting your important files üîëüîê.....Making it unreadable to u üñæüñæüñæ",
             "Launching Brute-Force-Attack and adding your ip address to botnets!!! üìçüìçüìç",
             f"Selling your sensitive data to ha*** üé≠ and got a profit worth {x} dollars ü§ë ",
             f"The dangerous hack has been completed and {member.mention} system has been filled with viruses üíÄüíÄüíÄ!!!"]
    for i in texts:
        await asyncio.sleep(3)
        await my_msg.edit(content=i)


@bot.command(name="profile")  # Profile of a player
async def profile(ctx: commands.Context, enemy: discord.Member = None):
    ''' Displays might, name, avatar'''
    if user_info.find_one({'id': ctx.author.id}) == None:
        await ctx.send('Please start using `?start`!')
        return
    used = time.time()
    last_used = float(user_time_info.find_one(
        {'id': ctx.author.id})['profile_time'])
    if(used - last_used < 20):
        em = discord.Embed(title="You are on cool down!", description='You can use this command in '+str(
            20-int(used - last_used))+" seconds"+"\nDefault cooldown for this command is 20 seconds")
        await ctx.reply(embed=em)
        return
    else:
        last_used = time.time()
        user_time_info.update_one({'id': ctx.author.id}, {
            '$set': {'profile_time': last_used}})
        if user_info.find_one({'id': ctx.author.id}) == None:
            await ctx.send('Please start using `?start`!')
        if(enemy == None):
            embedobj = discord.Embed(
                title=ctx.author
            )
            embedobj.set_thumbnail(url=ctx.author.avatar_url)
            get_data = user_info.find_one({'id': ctx.author.id})
            filtr = {'id': ctx.author.id}
            update_data = user_info.find_one_and_update
            mighter = might(get_data['t1'], get_data['t2'], get_data['t3'])
            update_data(filtr, {'$set': {'might': mighter}})
            embedobj.add_field(name='Might', value=user_info.find_one(
                {'id': ctx.author.id})['might'])
            embedobj.add_field(name='Tier 1', value=user_info.find_one(
                {'id': ctx.author.id})['t1'])
            embedobj.add_field(name='Tier 2', value=user_info.find_one(
                {'id': ctx.author.id})['t2'])
            embedobj.add_field(name='Tier 3', value=user_info.find_one(
                {'id': ctx.author.id})['t3'])
            embedobj.add_field(name='Training potions', value=user_info.find_one(
                {'id': ctx.author.id})['potions'])
            total_troops = get_data['t1']+get_data['t2']+get_data['t3']
            embedobj.add_field(name='Total troops', value=total_troops)
            try:
                await ctx.author.send(embed=embedobj)
            except Exception as error:
                await ctx.send(embed=embedobj)

        elif(user_info.find_one({'id': enemy.id})):
            embedobj = discord.Embed(title=enemy)
            embedobj.set_thumbnail(url=enemy.avatar_url)
            get_data_enemy = user_info.find_one({'id': enemy.id})
            filtr_enemy = {'id': enemy.id}
            update_enemy_data = user_info.find_one_and_update
            enemy_mighter = might(
                get_data_enemy['t1'], get_data_enemy['t2'], get_data_enemy['t3'])
            update_enemy_data(filtr_enemy, {'$set': {'might': enemy_mighter}})
            embedobj.add_field(name='Might', value=user_info.find_one(
                {'id': enemy.id})['might'])
            await ctx.reply(embed=embedobj)
        elif(user_info.find_one({'id': enemy.id}) == None):
            await ctx.send("The players hasn't started the game yet!")
        else:
            await ctx.send("It's a bug try using correct command")


@bot.command(name='potion')
async def potion_count(ctx: commands.Context):
    ''' Sends the potion count in dm '''
    if user_info.find_one({'id': ctx.author.id}) == None:
        await ctx.send('Please start using `?start`!')
        return
    used = time.time()
    last_used = float(user_time_info.find_one(
        {'id': ctx.author.id})['potion_time'])
    if(used - last_used < 20):
        em = discord.Embed(title="You are on cool down!", description='You can use this command in '+str(
            20-int(used - last_used))+" seconds"+"\nDefault cooldown for this command is 20 seconds")
        await ctx.reply(embed=em)
        return
    else:
        last_used = time.time()
        user_time_info.update_one({'id': ctx.author.id}, {
            '$set': {'potion_time': last_used}})
        if user_info.find_one({'id': ctx.author.id}) == None:
            await ctx.send('Please start using `?start`!')
        try:
            await ctx.author.send("You currently have "+str(user_info.find_one({'id': ctx.author.id})['potions'])+" training potions")
        except Exception as error:
            await ctx.channel.send("You currently have "+str(user_info.find_one({'id': ctx.author.id})['potions'])+" training potions")


@bot.command(name="beg")  # Easier, low-prize training potions
async def beg(ctx: commands.Context):
    ''' Gives low potion (high probability)'''
    if user_info.find_one({'id': ctx.author.id}) == None:
        await ctx.send('Please start using `?start`!')
        return
    used = time.time()
    last_used = float(user_time_info.find_one(
        {'id': ctx.author.id})['beg_time'])
    if(used - last_used < 20):
        em = discord.Embed(title="You are on cool down!", description='You can use this command in '+str(
            20-int(used - last_used))+" seconds"+"\nDefault cooldown for this command is 20 seconds")
        await ctx.reply(embed=em)
        return
    else:
        last_used = time.time()
        user_time_info.update_one({'id': ctx.author.id}, {
            '$set': {'beg_time': last_used}})
        if user_info.find_one({'id': ctx.author.id}) == None:
            await ctx.send('Please start using `?start`!')
        elif(user_info.find_one({'id': ctx.author.id})):
            last = time.time()
            user_time_info.update_one({'id': ctx.author.id}, {
                '$set': {'beg_time': last}})

            trmp = random.randint(1, 2)
            if(trmp == 1):
                await ctx.reply("You got 0 training potions")
            else:
                x = random.randint(0, 1000)  # x is potions obtained in beg
                user_info.update_one({'id': ctx.author.id}, {
                    '$inc': {'potions': +x}})
                await ctx.reply(f"Congratulations you got {x} training potions")
        else:
            await ctx.send("It\'s a bug try using correct command")


@bot.command(name="resources")  # Harder, high-prize training potions
@commands.guild_only()
async def beg(ctx: commands.Context):
    ''' Get high potions(less probability)'''
    if user_info.find_one({'id': ctx.author.id}) == None:
        await ctx.send('Please start using `?start`!')
        return
    used = time.time()
    last_used = float(user_time_info.find_one(
        {'id': ctx.author.id})['resources_time'])
    if(used - last_used < 20):
        em = discord.Embed(title="You are on cool down!", description='You can use this command in '+str(
            20-int(used - last_used))+" seconds"+"\nDefault cooldown for this command is 20 seconds")
        await ctx.reply(embed=em)
        return
    else:
        last_used = time.time()
        user_time_info.update_one({'id': ctx.author.id}, {
            '$set': {'resources_time': last_used}})
        if user_info.find_one({'id': ctx.author.id}) == None:
            await ctx.send('Please start using `?start`!')
        elif(user_info.find_one({'id': ctx.author.id})):
            trmp = random.randint(1, 3)
            if(trmp == 2):
                # x is potions obtained in resources
                x = random.randint(15, 1000)*10
                user_info.update_one({'id': ctx.author.id}, {
                    '$inc': {'potions': +x}})
                await ctx.reply(f"Congratulations you got {x} training potions")
            else:
                await ctx.reply("You got 0 training potions")
        else:
            await ctx.send("It\'s a bug try using correct command")


@bot.command(name="train")  # Training the soldiers
@commands.guild_only()
# tier -  troop tier to train, Amount - No. of troops to train
async def training(ctx: commands.Context, tier: int = None, amount: int = None):
    ''' Used to train troops `?train <tier> <troops_amount>` Eg: ||?train 3 100||'''
    if user_info.find_one({'id': ctx.author.id}) == None:
        await ctx.send('Please start using `?start`!')
        return
    used = time.time()
    last_used = float(user_time_info.find_one(
        {'id': ctx.author.id})['train_time'])
    if(used - last_used < 20):
        em = discord.Embed(title="You are on cool down!", description='You can use this command in '+str(
            20-int(used - last_used))+" seconds"+"\nDefault cooldown for this command is 20 seconds")
        await ctx.reply(embed=em)
        return
    else:
        last_used = time.time()
        user_time_info.update_one({'id': ctx.author.id}, {
            '$set': {'train_time': last_used}})
        try:
            result = {}
            if(tier == None or amount == None):
                await ctx.send(f"{ctx.author.mention} Give the argument correctly like `?train <tier> <troops_amount>`")
            elif(user_info.find_one({'id': ctx.author.id})):
                if user_info.find_one({'id': ctx.author.id}) == None:
                    await ctx.send(f"{ctx.author.mention}Please start using `?start`!")
                    return
                get_data = user_info.find_one({'id': ctx.author.id})
                update_data = user_info.find_one_and_update
                filtr = {'id': ctx.author.id}
                troop_count = amount
                train_pot = get_data['potions']
                tier = tier
                t1 = get_data['t1']
                t2 = get_data['t2']
                t3 = get_data['t3']

                if(tier == 1):
                    if(troop_count*p_t1 > train_pot):
                        await ctx.send(f"{ctx.author.mention} Not enough training potions. Type``?train_cost`` for information")
                        return
                    else:
                        train_pot = train_pot-troop_count*p_t1  # if yes train the tier 1 troops
                        t1 += troop_count
                        result = {
                            'training_train_pot': train_pot,
                            'tier1': t1,
                            'tier2': t2,
                            'tier3': t3
                        }
                elif(tier == 2):
                    # checks whether we have enough training costs for training t2
                    if(troop_count*p_t2 > train_pot):
                        await ctx.send(f"{ctx.author.mention} Not enough training potions. Type``?train_cost`` for information")
                        return
                    else:  # if yes train the tier 2 troops
                        train_pot = train_pot-troop_count*p_t2
                        t2 += troop_count
                        result = {
                            'training_train_pot': train_pot,
                            'tier1': t1,
                            'tier2': t2,
                            'tier3': t3
                        }

                elif(tier == 3):  # checks whether we have enough training costs for training t3
                    if(troop_count*p_t3 > train_pot):
                        await ctx.send(f"{ctx.author.mention} Not enough training potions. Type``?train_cost`` for information")
                        return
                    else:  # if yes train the tier 3 troops
                        train_pot = train_pot-troop_count*p_t3
                        t3 += troop_count
                        result = {
                            'training_train_pot': train_pot,
                            'tier1': t1,
                            'tier2': t2,
                            'tier3': t3
                        }

                else:
                    # if we gave invalid tier print no such tier exist
                    await ctx.send(f"{ctx.author.mention} No such tier troops exist. Tiers available from 1-3")
                    return
                update_data(filtr, {'$set': {
                    't1': result['tier1'], 't2': result['tier2'], 't3': result['tier3'], 'potions': result['training_train_pot']}})
                await ctx.send(f"{ctx.author.mention}You have successfully trained {amount} tier {tier} troops")
            elif(user_info.find_one({'id': ctx.author.id}) == None):
                await ctx.reply('Please start using `?start` command')
            else:
                await ctx.send("Give the argument correctly like `?train <tier> <troops_amount>`")
        except:
            await ctx.send(f"(ctx.author.mention) use commands correctly. Type `?help train` for more information")


@bot.command(name="scout")  # Scouting the player
@commands.guild_only()
async def scout(ctx: commands.Context, enemy: discord.Member = None):
    ''' Used to scout enemy `?scout <enemy?` Eg: ||?scout @kingdomfight||'''
    if user_info.find_one({'id': ctx.author.id}) == None:
        await ctx.send('Please start using `?start`!')
        return
    used = time.time()
    last_used = float(user_time_info.find_one(
        {'id': ctx.author.id})['scout_time'])
    if(used - last_used < 45):
        em = discord.Embed(title="You are on cool down!", description='You can use this command in '+str(
            45-int(used - last_used))+" seconds"+"\nDefault cooldown for this command is 45 seconds")
        await ctx.reply(embed=em)
        return
    else:
        last_used = time.time()
        user_time_info.update_one({'id': ctx.author.id}, {
            '$set': {'scout_time': last_used}})
        if(enemy == None):
            await ctx.send('Tag someone to scout!')
        elif user_info.find_one({'id': ctx.author.id}) == None:
            await ctx.send('Please start using `?start`!')
        elif user_info.find_one({'id': enemy.id}) == None:
            await ctx.send('Player you scouted hasn\'t started using the bot')
        elif(enemy == ctx.author):
            await ctx.reply("You can't scout yourself")
        elif(user_info.find_one({'id': enemy.id})):
            fltr = {'id': enemy.id}
            data = user_info.find_one(fltr)
            em = discord.Embed(title=f'{enemy}\'s Scout Report!')
            em.add_field(name='Tier 1', value=data['t1'])
            em.add_field(name='Tier 2', value=data['t2'])
            em.add_field(name='Tier 3', value=data['t3'])
            em.add_field(name='Potions', value=data['potions'])
            total_troops = data['t1']+data['t2']+data['t3']
            em.add_field(name='Total troops', value=total_troops)
            await ctx.reply(embed=em)
            await enemy.send(f"{ctx.author} is scouting your troops")
        else:
            await ctx.send("Use `?scout <member>`")


# working


@bot.command(name='fight')  # fighting with others
@commands.guild_only()
async def fighting(ctx: commands.Context, enemy: discord.Member = None):
    ''' Used to fight enemy `?fight <enemy?` Eg: ||?fight @kingdomfight||'''
    if user_info.find_one({'id': ctx.author.id}) == None:
        await ctx.send('Please start using `?start`!')
        return
    used = time.time()
    last_used = float(user_time_info.find_one(
        {'id': ctx.author.id})['fight_time'])
    if(used - last_used < 300):
        em = discord.Embed(title="You are on cool down!", description='You can use this command in '+str(
            300-int(used - last_used))+" seconds"+"\nDefault cooldown for this command is 5 minutes")
        await ctx.reply(embed=em)
        return
    else:
        last_used = time.time()
        user_time_info.update_one({'id': ctx.author.id}, {
            '$set': {'fight_time': last_used}})
        if(enemy == None):
            await ctx.send(f'{ctx.author.mention} Tag someone to attack!')
        elif user_info.find_one({'id': ctx.author.id}) == None:
            await ctx.send(f'{ctx.author.mention} Please start using `?start`!')
        elif user_info.find_one({'id': enemy.id}) == None:
            await ctx.send(f"{ctx.author.mention} Player you trying to attack hasn't started using the bot")
        elif(enemy == ctx.author):
            await ctx.reply(f"{ctx.author.mention} You can't attack yourself")
        elif(user_info.find_one({'id': enemy.id})):
            try:
                author_filtr = {'id': ctx.author.id}
                author_get_data = user_info.find_one(author_filtr)
                update_data = user_info.find_one_and_update
                enemy_filtr = {'id': enemy.id}
                enemy_get_data = user_info.find_one(enemy_filtr)
                t1 = author_get_data['t1']
                t2 = author_get_data['t2']
                t3 = author_get_data['t3']
                train_pot = author_get_data['potions']
                et1 = enemy_get_data['t1']
                et2 = enemy_get_data['t2']
                et3 = enemy_get_data['t3']
                etrain_pot = enemy_get_data['potions']
                b = 0
                eb = 0
                loss1 = 0
                loss2 = 0
                loss3 = 0
                eloss1 = 0
                eloss2 = 0
                eloss3 = 0  # 10,20,20,5,6,32
                edamage = t1*2+t2*8+t3*24  # edamage=51380
                damage = et1*2+et2*8+et3*24  # damage=16958
                if(damage <= edamage):
                    win = True
                    train_pot += int(etrain_pot/5)
                    etrain_pot -= int(etrain_pot/5)
                else:
                    win = False
                    etrain_pot += int(train_pot/5)
                    train_pot -= int(train_pot/3)
                if(edamage > damage):
                    damage = damage/8.85
                    edamage = edamage/2.9
                    damage = int(damage)
                    edamage = int(edamage)
                elif(edamage < damage):
                    edamage = edamage/8.3
                    damage = damage/1.8
                    damage = int(damage)
                    edamage = int(edamage)
                else:
                    damage = damage/4.2
                    edamage = edamage/4.2
                    damage = int(damage)
                    edamage = int(edamage)
                d_t1 = (damage/2)
                d_t1 = int(d_t1)  # d_t1=816
                if(d_t1 >= t1):
                    loss1 = t1  # loss1=10
                    t1 = 0  # t1(left)=0
                    exdamage1 = damage-loss1*2  # extradamage1=9800
                else:
                    loss1 = d_t1
                    t1 = (t1-d_t1)
                    exdamage1 = 0
                    ++b
                if(b == 0):
                    d_t2 = exdamage1/8  # d_t2=245
                    d_t2 = int(d_t2)
                    if(d_t2 >= t2):
                        loss2 = t2  # loss2=20
                        t2 = 0  # t2(left)=0
                        exdamage2 = exdamage1-loss2*8  # extradamage2=9000
                    else:
                        loss2 = d_t2
                        t2 = (t2-d_t2)
                        exdamage2 = 0
                        ++b
                if(b == 0):
                    d_t3 = exdamage2/24  # d_t3=20
                    d_t3 = int(d_t3)
                    if(d_t3 >= t3):
                        loss3 = t3
                        t3 = 0
                    else:
                        loss3 = d_t3  # loss3=20
                        t3 = (t3-d_t3)  # t3(left)=2

                ed_t1 = (edamage/2)  # d_t1=816
                ed_t1 = int(ed_t1)
                if(ed_t1 >= et1):
                    eloss1 = et1  # loss1=10
                    et1 = 0  # t1(left)=0
                    eexdamage1 = edamage-loss1*2  # extradamage1=9800
                else:
                    eloss1 = ed_t1
                    et1 = (et1-ed_t1)
                    eexdamage1 = 0
                    ++eb
                if(eb == 0):
                    ed_t2 = eexdamage1/8  # d_t2=245
                    ed_t2 = int(ed_t2)
                    if(ed_t2 >= et2):
                        eloss2 = et2  # loss2=20
                        et2 = 0  # t2(left)=0
                        eexdamage2 = eexdamage1-eloss2*8  # extradamage2=9000
                    else:
                        eloss2 = ed_t2
                        et2 = (et2-ed_t2)
                        eexdamage2 = 0
                        ++eb
                if(eb == 0):
                    ed_t3 = eexdamage2/24  # d_t3=20
                    ed_t3 = int(ed_t3)
                    if(ed_t3 >= et3):
                        eloss3 = et3
                        et3 = 0
                    else:
                        eloss3 = ed_t3  # loss3=20
                        et3 = (et3-ed_t3)  # t3(left)=2
                edamage = eloss1*2+eloss2*8+eloss3*24  # edamage=9920
                damage = loss1*2+loss2*8+loss3*24  # damage=9900
                dmg_stats = [damage, edamage, t1, t2, t3,
                             train_pot, et1, et2, et3, etrain_pot]
                res = [win, dmg_stats]

                update_data(author_filtr, {'$set': {
                            't1': res[1][2], 't2': res[1][3], 't3': res[1][4], 'potions': res[1][5]}})
                update_data(enemy_filtr, {'$set': {
                            't1': res[1][6], 't2': res[1][7], 't3': res[1][8], 'potions': res[1][9]}})
            except:
                await ctx.send(f"{ctx.author.mention} Give command properly. Type ``?help fight`` for help")
            if(res[0] == True):
                await ctx.send(f"{ctx.author.mention} attacked {enemy.mention} and took the leader in chains")
                await enemy.send(f"{ctx.author.mention} attacked you and took your leader in chains")
            else:
                await ctx.send(f"{ctx.author.mention} attacked {enemy.mention} and got defeated. The attacking leader got captured")
                await enemy.send(f"{ctx.author.mention} attacked you. You won in this battle")
            tot_might_loss = res[1][0]+res[1][1]
            await ctx.send(f"Total might loss in this battle is {tot_might_loss}")
            await enemy.send(f"Total might loss in this battle is {tot_might_loss}")
        else:
            await ctx.send(f"{ctx.author.mention} Use `?fight <enemy_tag>")


@bot.command(name="close")  # closes the terminal üòÅ:)
@commands.guild_only()
async def close(ctx):
    '''Used to stop the bot. Only available for developers üòÖ'''
    if ctx.author.id in [768016269269925911, 811919559086702642, 790790711326277652]:
        await ctx.send(f'{ctx.author.mention}You successfully closed the bot!!!')
        await quit()
    else:
        await ctx.reply('This is only for owners üòé!')


@bot.command(name="invite")  # invite link for the bot
async def invite(ctx):
    '''Gives the invite link of the bot'''
    await ctx.send("http://tiny.cc/EXPLOITER")


@bot.command(name="meme")
@commands.guild_only()
async def meme(ctx):
    '''Post a meme'''
    r = requests.get("https://memes.blademaker.tv/api?lang=en")
    res = r.json()
    title = res["title"]
    ups = res["ups"]
    downs = res["downs"]
    comments = res['score']
    memes = discord.Embed(title=f"{title}")
    memes.set_image(url=res["image"])
    memes.set_footer(text=f"üëç : {ups}   üí¨ : {comments}")
    await ctx.send(embed=memes)


@bot.command(name="quote")
@commands.guild_only()
async def quote(ctx: commands.context, day: str = None):
    '''``?quote`` to get random quote and ``?quote today`` to get today's quote'''
    if(day == None):
        response = requests.get("https://zenquotes.io/api/random")
        zen = (response.json())
        await ctx.reply(zen[0]['q']+"\n                                          \t\t\t-"+zen[0]['a'])
    elif(day == "today"):
        response = requests.get("https://zenquotes.io/api/today")
        zen = response.json()
        await ctx.reply(zen[0]['q']+"\n                                          \t\t\t-"+zen[0]['a'])
    else:
        await ctx.reply("``?quote`` to get random quote and ``?quote today`` to get today's quote")


@bot.command(name="grole")
@commands.guild_only()
@commands.has_permissions(administrator=True)
async def grole(ctx, role: discord.Role):
    serverId = ctx.message.guild.id
    if server_info.find_one({'id': serverId}):
        server_info.update_one({'id': serverId}, {
            '$set': {'role': role.name}})
        await ctx.send(f"You fixed {role.name} as giveaway role")
    else:
        server_Doc = {
            'id': int(serverId), 'role': role.name
        }
        server_info.insert_one(server_Doc)
        await ctx.send(f"You fixed {role.name} as giveaway role")


@bot.command(name="gcreate")
@commands.guild_only()
async def gcreate(ctx):
    serverId = ctx.message.guild.id
    try:
        role = str(server_info.find_one(
            {'id': serverId})['role'])
    except:
        await ctx.send("Ask admin to set a giveaway role by using ``grole`` command!")
        return
    if server_info.find_one({'id': serverId}) == None:
        await ctx.send("Ask admin to set a giveaway role by using ``grole`` command!")
        return
    serverId = ctx.message.guild.id
    role = str(server_info.find_one(
        {'id': serverId})['role'])
    check_role = get(ctx.message.guild.roles, name=role)
    if check_role in ctx.author.roles:
        '''Used to start the giveaway in the any channel Eg:||?gcreate #giveaway 10s 1w dank coins||.Use (s-seconds|m-minutes|h-hour|d-day and w-winners)Giveaways require ``giveaway`` role. Ask the owner to create a role name ``giveaway`` if there is no role'''
        await ctx.send("Let's start the giveaway! Answer these questions within 20 seconds")
        questions = ["Which channel should the giveaway be hosted in?",
                     "What should be the duration of the giveaway? (s-seconds|m-minutes|h-hour|d-day)",
                     "Number of winners in the giveaway?",
                     "What is the prize of the giveaway?"]
        answers = []

        def check(m):
            return m.author == ctx.author and m.channel == ctx.channel
        for i in questions:
            await ctx.send(i)
            try:
                msg = await bot.wait_for('message', timeout=20.0, check=check)
            except asyncio.TimeoutError:
                await ctx.send("You didn't answered in time, please answer at next time!")
                return
            else:
                answers.append(msg.content)
        try:
            c_id = int(answers[0][2:-1])
        except:
            await ctx.send(f"You didn't mention a channel correctly.Do it like this {ctx.channel.mention} next time")
            return
        channel = bot.get_channel(c_id)
        time = convert(answers[1])
        if time == -1:
            await ctx.send(f"You didn't answer the time with proper unit. Use (s-seconds|m-minutes|h-hour|d-day) next time!")
            return
        elif time == -2:
            await ctx.send(f"The time must be in integer. Please enter the integer")
            return
        no_winners = answers[2]
        prize = answers[3]
        if(no_winners.isnumeric() == True):
            no_winners = int(no_winners)
        else:
            await channel.send("you gave non-integer values for winners")
            return
        if(answers[1][-1] == "s"):
            prefix = "seconds"
        elif(answers[1][-1] == "m"):
            prefix = "minutes"
        elif(answers[1][-1] == "h"):
            prefix = "hours"
        elif(answers[1][-1] == "d"):
            prefix = "days"
        n = len(answers[1])
        announce_time = answers[1][0:n-1]
        await ctx.send(f"The Giveaway will be in channel {channel.mention} and will last for {answers[1]} !")
        giveaway = discord.Embed(
            title="**üéâ GIVEAWAY üéâ**",
            description=f"**Prize:** {prize}",
            colour=discord.Color.green()
        )
        giveaway.add_field(name="**Hosted By:**",
                           value=ctx.author.mention, inline=False)
        giveaway.add_field(name="No of winners",
                           value=f"{no_winners}", inline=False)

        msg = await channel.send(embed=giveaway)

        reactions = await msg.add_reaction("üéâ")
        my_msg = await channel.fetch_message(msg.id)
        while time > 0:
            if time <= 60:
                try:
                    my_msg = await channel.fetch_message(msg.id)
                    check_lst = await str(my_msg.embeds[0].fields[2])
                    check = await check_lst.split("'")[1]
                    if(check == "Winner is :"):
                        return
                    await asyncio.sleep(1)
                    check_lst = await str(my_msg.embeds[1].fields[100])
                except:
                    giveaway.remove_field(index=2)
                    giveaway.insert_field_at(
                        index=2, name='Ends:', value=f'{time} second(s) from now')
                    await my_msg.edit(embed=giveaway)
                    time -= 10
                    await asyncio.sleep(9)
            elif 60 < time <= 3600:
                try:
                    my_msg = await channel.fetch_message(msg.id)
                    check_lst = await str(my_msg.embeds[0].fields[2])
                    check = await check_lst.split("'")[1]
                    if(check == "Winner is :"):
                        return
                    await asyncio.sleep(1)
                    check_lst = await str(my_msg.embeds[1].fields[100])
                except:
                    giveaway.remove_field(index=2)
                    giveaway.insert_field_at(
                        index=2, name='Ends:', value=f'{time/60} minute(s) from now')
                    await my_msg.edit(embed=giveaway)
                    time -= 6
                    await asyncio.sleep(5)
            elif 3600 < time <= 86400:
                try:
                    my_msg = await channel.fetch_message(msg.id)
                    check_lst = await str(my_msg.embeds[0].fields[2])
                    check = await check_lst.split("'")[1]
                    if(check == "Winner is :"):
                        return
                    await asyncio.sleep(1)
                    check_lst = str(my_msg.embeds[1].fields[100])
                except:
                    giveaway.remove_field(index=2)
                    giveaway.insert_field_at(
                        index=2, name='Ends:', value=f'{time/3600} hour(s) from now')
                    await my_msg.edit(embed=giveaway)
                    time -= 360
                    await asyncio.sleep(359)
            elif time > 86400:
                try:
                    my_msg = await channel.fetch_message(msg.id)
                    check_lst = await str(my_msg.embeds[0].fields[2])
                    check = await check_lst.split("'")[1]
                    if(check == "Winner is :"):
                        return
                    await asyncio.sleep(1)
                    check_lst = await str(my_msg.embeds[1].fields[100])
                except:
                    giveaway.remove_field(index=2)
                    giveaway.insert_field_at(
                        index=2, name='Ends:', value=f'{time/86400} day(s) from now')
                    await my_msg.edit(embed=giveaway)
                    time -= 8640
                    await asyncio.sleep(8639)
        if time <= 0:
            try:
                my_msg = await channel.fetch_message(msg.id)
                check_lst = await str(my_msg.embeds[0].fields[2])
                check = await check_lst.split("'")[1]
                if(check == "Winner is :"):
                    return
                check_lst = await str(my_msg.embeds[1].fields[100])
            except:
                giveaway.remove_field(index=2)
                giveaway.insert_field_at(index=2, name='Ends:', value=f'Ended at {datetime.datetime.now().strftime("%B %d, %I:%M %p")}')  # noqa
                await my_msg.edit(embed=giveaway)

        await asyncio.sleep(time)
        new_msg = await channel.fetch_message(msg.id)
        try:
            users = await new_msg.reactions[0].users().flatten()
            users.pop(users.index(bot.user))
            counts = len(users)

            if(no_winners > counts or no_winners <= 0):
                await channel.send("Not enough members ")
                new_embed = discord.Embed(
                    new_title="Giveaway has been ended!!!", description=f"{prize}", Color=ctx.author.color)
                new_embed.add_field(name="Hosted by: ",
                                    value=ctx.author.mention)
                new_embed.add_field(name="No of winners",
                                    value=no_winners, inline=False)
                new_embed.set_footer(
                    text=f"Giveaway closed due to less participants!")
                await new_msg.edit(embed=new_embed)
                return
            winners_announce = ""
            winner = random.sample(users, no_winners)
            for i in winner:
                winners_announce += i.mention + " "
            new_embed = discord.Embed(
                title="Giveaway!", description=f"{prize}", Color=ctx.author.color)
            new_embed.add_field(name="Hosted by: ", value=ctx.author.mention)
            new_embed.add_field(name="No of winners",
                                value=no_winners, inline=False)
            new_embed.add_field(name="Winner is : ",
                                value=winners_announce, inline=False)
            new_embed.set_footer(text="This giveaway has been ended")
            await new_msg.edit(embed=new_embed)
            await channel.send(f"Congratulations! {winners_announce} you won {prize}!.\nTotal entries = {counts} entrants ‚ÜóÔ∏è")
        except:
            await channel.send(f"The Giveaway has been cancelled because of lesser number of participants or someone cancelled the Giveaway")
    else:
        await ctx.reply(f"You don't have the required {role} role to use this command!!! ")


@bot.command(name="gend")
@commands.guild_only()
async def gend(ctx: commands.Context, channel: discord.TextChannel, id_: int):
    await ctx. message. delete()
    serverId = ctx.message.guild.id

    try:
        role = str(server_info.find_one(
            {'id': serverId})['role'])
    except:
        await ctx.send("Ask admin to set a giveaway role by using ``grole`` command!")
        return
    if server_info.find_one({'id': serverId}) == None:
        await ctx.send("Ask admin to set a giveaway role by using ``grole`` command!")
        return
    role = str(server_info.find_one(
        {'id': serverId})['role'])
    check_role = get(ctx.message.guild.roles, name=role)
    if check_role in ctx.author.roles:
        '''Used to reroll the giveaway in the current channel Eg:||?greroll #channel-id(of the required giveaway) #id of the required giveaway||Giveaways require ``giveaway`` role. Ask the owner to create a role name ``giveaway`` if there is no role. Don't reroll while the giveaway is ongoing'''
        try:
            new_msg = await channel.fetch_message(id_)
            # await ctx.send(new_msg)
        except:
            await ctx.send("The id was entered incorrectly")
            return
        winners = ""
        # try:
        try:
            check_lst = str(new_msg.embeds[0].fields[2])
            check = check_lst.split("'")[1]
        except:
            await ctx.send("The id was entered incorrectly")
            return
        if(check == "Winner is :"):
            await ctx.send("This giveaway has already ended")
            return
        else:
            if(check == "Ends:"):
                host_lst1 = str(new_msg.embeds[0].fields[1])
                host_lst = str(new_msg.embeds[0].fields[0])
                host_value = host_lst.split("'")[3]
                winner_value = host_lst1.split("'")[3]
                winner_value = int(winner_value)
                prize = new_msg.embeds[0].description
                users = await new_msg.reactions[0].users().flatten()
                users.pop(users.index(bot.user))
                counts = len(users)
                winner = random.sample(users, winner_value)
                for i in winner:
                    winners += i.mention + " "
                new_embed = discord.Embed(
                    title="Giveaway!", description=f"{prize}", Color=ctx.author.color)
                new_embed.add_field(name="Hosted by: ",
                                    value=host_value, inline=False)
                new_embed.add_field(name="No of winners",
                                    value=winner_value, inline=False)
                new_embed.add_field(name="Winner is : ",
                                    value=winners, inline=False)
                new_embed.set_footer(text="This giveaway has been ended")
                # await new_msg.delete()
                await new_msg.edit(embed=new_embed)
                await channel.send(f"Congratulations! {winners} you won {prize} !. Total entries = {counts} entrants ‚ÜóÔ∏è")
            else:
                await ctx.send("Can not reroll this one!!!")
        # except:
        #     await channel.send("Can not reroll this one!!!")
    else:
        await ctx.send(f"You don't have the required {role} role to use this command!!! ")


@bot.command(name="greroll")
@commands.guild_only()
async def greroll(ctx: commands.Context, channel: discord.TextChannel, id_: int):
    await ctx. message. delete()
    serverId = ctx.message.guild.id
    try:
        role = str(server_info.find_one(
            {'id': serverId})['role'])
    except:
        await ctx.send("Ask admin to set a giveaway role by using ``grole`` command!")
        return
    if server_info.find_one({'id': serverId}) == None:
        await ctx.send("Ask admin to set a giveaway role by using ``grole`` command!")
        return
    role = str(server_info.find_one(
        {'id': serverId})['role'])
    check_role = get(ctx.message.guild.roles, name=role)
    if check_role in ctx.author.roles:
        '''Used to reroll the giveaway in the current channel Eg:||?greroll #channel-id(of the required giveaway) #id of the required giveaway||Giveaways require ``giveaway`` role. Ask the owner to create a role name ``giveaway`` if there is no role. Don't reroll while the giveaway is ongoing'''
        try:
            try:
                new_msg = await channel.fetch_message(id_)
            except:
                await ctx.send("The id was entered incorrectly")
                return
            my_msg = await channel.fetch_message(new_msg.id)
            check_lst = str(my_msg.embeds[0].fields[2])
            check = check_lst.split("'")[1]
            if(check == "Ends:"):
                await ctx.reply('This give away is acitve!!!')
                return
            elif(check == "Winner is :"):
                embed_copy = new_msg.embeds[0].copy()
                number_winners_list = str(new_msg.embeds[0].fields[1])
                # host_list=str(new_msg.embeds[0].fields[0])
                number_winners = int(number_winners_list.split("'")[3])
                # host_value=(host_list.split("'")[2])
                # await ctx.send(host_value)
                prize = new_msg.embeds[0].description
                # await ctx.send(prize)

                users = await new_msg.reactions[0].users().flatten()
                users.pop(users.index(bot.user))
                counts = len(users)
                if(counts < number_winners):
                    await channel.send("Don't have enough members!!!")
                    return
                winner = random.sample(users, number_winners)
                winners = ""
                for i in winner:
                    winners += i.mention + "  "
                embed_copy.remove_field(index=2)
                embed_copy.insert_field_at(
                    index=2, name='Winner is :', value=winners)
                await new_msg.edit(embed=embed_copy)
                await channel.send(f"Congratulations! {winners} you won {prize} !. \nTotal entries = {counts} entrants ‚ÜóÔ∏è")
            else:
                await ctx.reply("Try selecting correct id!!!")

        except:
            await ctx.send("Can not reroll this giveaway!!!.Check whether the giveaway ended or not")
    else:
        await ctx.send(f"You don't have the required {role} role to use this command!!! ")


@bot.command(name="gstart")
@commands.guild_only()
async def gstart(ctx: commands.Context, timer: str, winner: str, *args):
    await ctx. message. delete()
    serverId = ctx.message.guild.id
    try:
        role = str(server_info.find_one(
            {'id': serverId})['role'])
    except:
        await ctx.send("Ask admin to set a giveaway role by using ``grole`` command!")
        return
    if server_info.find_one({'id': serverId})['role'] == None:
        await ctx.send("Ask admin to set a giveaway role by using ``grole`` command!")
        return
    serverId = ctx.message.guild.id
    role = str(server_info.find_one(
        {'id': serverId})['role'])
    check_role = get(ctx.message.guild.roles, name=role)
    if check_role in ctx.author.roles:
        '''Used to start the giveaway in the current channel Eg:||?gstart 10s 1w dank coins||.Use (s-seconds|m-minutes|h-hour|d-day and w-winners)Giveaways require ``giveaway`` role. Ask the owner to create a role name ``giveaway`` if there is no role'''
        time = convert(timer)
        if time == -1:
            await ctx.send(f"You didn't answer the time with proper unit. Use (s-seconds|m-minutes|h-hour|d-day) next time!")
            return
        elif time == -2:
            await ctx.send(f"The time must be in integer. Please enter the integer")
            return
        if(winner[-1] == "w"):
            n = len(winner)
            y = winner[0:n-1]
            try:
                winners = int(y)
            except ValueError:
                await ctx.send(f"The winner must be in integer. Please enter the integer! Eg: 1w-for 1 winner")
                return
        else:
            y = winner
            try:
                winners = int(y)
            except ValueError:
                await ctx.send(f"The winner must be in integer. Please enter the integer! Eg: 1w-for 1 winner")
                return
        prize = ' '.join(args)
        if(timer[-1] == "s"):
            prefix = "seconds"
        elif(timer[-1] == "m"):
            prefix = "minutes"
        elif(timer[-1] == "h"):
            prefix = "hours"
        elif(timer[-1] == "d"):
            prefix = "days"
        n = len(timer)
        announce_time = timer[0:n-1]
        await ctx.send("The giveaway is starting in this channel now!!!")
        await asyncio.sleep(2)
        await ctx.channel.purge(limit=1)
        giveaway = discord.Embed(
            title="**üéâ GIVEAWAY üéâ**",
            description=f"**Prize:** {prize}",
            colour=discord.Color.green()
        )
        giveaway.add_field(name="**Hosted By:**",
                           value=ctx.author.mention, inline=False)
        giveaway.add_field(name="No of winners",
                           value=f"{winners}", inline=False)

        msg = await ctx.send(embed=giveaway)

        reactions = await msg.add_reaction("üéâ")
        my_msg = await ctx.fetch_message(msg.id)
        while time > 0:
            if time <= 60:
                try:
                    my_msg = await ctx.fetch_message(msg.id)
                    check_lst = await str(my_msg.embeds[0].fields[2])
                    check = await check_lst.split("'")[1]
                    if(check == "Winner is :"):
                        return
                    await asyncio.sleep(1)
                    check_lst = await str(my_msg.embeds[1].fields[100])
                except:
                    giveaway.remove_field(index=2)
                    giveaway.insert_field_at(
                        index=2, name='Ends:', value=f'{time} second(s) from now')
                    await my_msg.edit(embed=giveaway)
                    time -= 10
                    await asyncio.sleep(9)
            elif 60 < time <= 3600:
                try:
                    my_msg = await ctx.fetch_message(msg.id)
                    check_lst = await str(my_msg.embeds[0].fields[2])
                    check = await check_lst.split("'")[1]
                    if(check == "Winner is :"):
                        return
                    check_lst = await str(my_msg.embeds[1].fields[100])
                except:
                    giveaway.remove_field(index=2)
                    giveaway.insert_field_at(
                        index=2, name='Ends:', value=f'{time/60} minute(s) from now')
                    await my_msg.edit(embed=giveaway)
                    time -= 6
                    await asyncio.sleep(5)
            elif 3600 < time <= 86400:
                try:
                    my_msg = await ctx.fetch_message(msg.id)
                    check_lst = await str(my_msg.embeds[0].fields[2])
                    check = await check_lst.split("'")[1]
                    if(check == "Winner is :"):
                        return
                    await asyncio.sleep(1)
                    check_lst = await str(my_msg.embeds[1].fields[100])
                except:
                    giveaway.remove_field(index=2)
                    giveaway.insert_field_at(
                        index=2, name='Ends:', value=f'{time/3600} hour(s) from now')
                    await my_msg.edit(embed=giveaway)
                    time -= 360
                    await asyncio.sleep(359)
            elif time > 86400:
                try:
                    my_msg = await ctx.fetch_message(msg.id)
                    check_lst = await str(my_msg.embeds[0].fields[2])
                    check = await check_lst.split("'")[1]
                    if(check == "Winner is :"):
                        return
                    await asyncio.sleep(1)
                    check_lst = await str(my_msg.embeds[1].fields[100])
                except:
                    giveaway.remove_field(index=2)
                    giveaway.insert_field_at(
                        index=2, name='Ends:', value=f'{time/86400} day(s) from now')
                    await my_msg.edit(embed=giveaway)
                    time -= 8640
                    await asyncio.sleep(8639)
        if time <= 0:
            try:
                my_msg = await ctx.fetch_message(msg.id)
                check_lst = await str(my_msg.embeds[0].fields[2])
                check = await check_lst.split("'")[1]
                if(check == "Winner is :"):
                    return
                await asyncio.sleep(1)
                check_lst = await str(my_msg.embeds[1].fields[100])
            except:
                giveaway.remove_field(index=2)
                giveaway.insert_field_at(index=2, name='Ends:', value=f'Ended at {datetime.datetime.now().strftime("%B %d, %I:%M %p")}')  # noqa
                await my_msg.edit(embed=giveaway)

        await asyncio.sleep(time)
        new_msg = await ctx.fetch_message(msg.id)
        try:
            users = await new_msg.reactions[0].users().flatten()
            users.pop(users.index(bot.user))
            counts = len(users)

            if(winners > counts or winners <= 0):
                await ctx.send("Not enough members ")
                new_embed = discord.Embed(
                    new_title="Giveaway has been ended!!!", description=f"{prize}", Color=ctx.author.color)
                new_embed.add_field(name="Hosted by: ",
                                    value=ctx.author.mention)
                new_embed.add_field(name="No of winners",
                                    value=winners, inline=False)
                new_embed.set_footer(
                    text=f"Giveaway closed due to less participants!")
                await new_msg.edit(embed=new_embed)
                return
            winners_announce = ""
            winner = random.sample(users, winners)
            for i in winner:
                winners_announce += i.mention + " "
            new_embed = discord.Embed(
                title="Giveaway!", description=f"{prize}", Color=ctx.author.color)
            new_embed.add_field(name="Hosted by: ", value=ctx.author.mention)
            new_embed.add_field(name="No of winners",
                                value=winners, inline=False)
            new_embed.add_field(name="Winner is : ",
                                value=winners_announce, inline=False)
            new_embed.set_footer(text="This giveaway has been ended")
            await new_msg.edit(embed=new_embed)
            await ctx.send(f"Congratulations! {winners_announce} you won {prize}!.\nTotal entries = {counts} entrants ‚ÜóÔ∏è")
        except:
            await ctx.send(f"The Giveaway has been cancelled because of lesser number of participants or someone cancelled the Giveaway")
    else:
        await ctx.send(f"You don't have the required {role} role to use this command!!! ")


@bot.command(aliases=['cl'])
@commands.guild_only()
@commands.has_permissions(manage_messages=True)
async def clear(ctx: commands.Context, amount=2):
    '''Clears the message Eg: ||?clear 100|| where 100 is no.of msg to deleted or purged'''
    try:
        await ctx.channel.purge(limit=amount)
    except:
        await ctx.send("Can't purge that much messages.If it is error check whether you gave meproper role !!!")


@bot.command(aliases=['k'])
@commands.guild_only()
@commands.has_permissions(kick_members=True)
async def kick(ctx: commands.Context, member: discord.Member, *, reason="No reason specified"):
    '''Kicks the specified member Eg: ||?kick @Exploiter <reason for kick>|| where @Exploiter is the person to be kicked'''
    try:
        if(member == bot.user):
            await ctx.send(f"{ctx.author.mention} You can't kick me. How dare u tried to kick me with my power!!!")
            return
        if(member == ctx.author):
            await ctx.send("You can't kick yourself")
            return
        if member.top_role < ctx.author.top_role:
            await ctx.send(f"{member} have been kicked from the server for the reason {reason} by {ctx.author.mention}")
            await member.kick(reason=reason)
            try:
                await member.send(f"You have been kicked from the server {ctx.guild.name} for the reason {reason}.")
            except:
                return
        else:
            await ctx.send(f"You can't kick{member.mention}.They had higher role than you !!!")
    except:
        await ctx.send("Give me proper role !!!")


@bot.command(aliases=['b'])
@commands.guild_only()
@commands.has_permissions(ban_members=True)
async def ban(ctx: commands.Context, member: discord.Member, *, reason="No reason specified"):
    '''Bans the specified member Eg: ||?ban @Exploiter <reason for ban>|| where @Exploiter is the person to be banned'''
    try:
        if(member == bot.user):
            await ctx.send(f"{ctx.author.mention} You can't ban me. How dare u tried to ban me with my power!!!")
            return
        if(member == ctx.author):
            await ctx.send("You can't ban yourself")
            return
        if member.top_role < ctx.author.top_role:
            await ctx.send(f"{member.name} have been banned from the server for the reason {reason} by {ctx.author.mention}.")
            await member.ban(reason=reason)
            try:
                await member.send(f"You have been banned from the server {ctx.guild.name} for reason {reason}")
            except:
                return
        else:
            await ctx.send(f"You can't ban{member.mention}.They had higher role than you !!!")
    except:
        await ctx.send("Give me proper role !!!")


@bot.command(aliases=['ub'])
@commands.guild_only()
@commands.has_permissions(ban_members=True)
async def unban(ctx: commands.Context, *, member):
    '''Unbans the specified member Eg: ||?unban @Exploiter|| where @Exploiter is the id of the person to be unbanned'''
    try:
        if(member == bot.user):
            await ctx.send(f"{ctx.author.mention} I am always unbanned. Don't send jokes here!!!")
            return
        banned_users = await ctx.guild.bans()
        member_name, member_disc = member.split('#')
        for banned_entry in banned_users:
            user = banned_entry.user
            if(user.name, user.discriminator) == (member_name, member_disc):
                await ctx.guild.unban(user)
                await ctx.send(member_name + " has been unbanned!")
                return
        await ctx.send(member+" was not found")
    except:
        await ctx.send("Give me proper role or mention the member properly !!!")


@bot.command(name="mute")
@commands.guild_only()
@commands.has_permissions(kick_members=True)
async def mute(ctx: commands.Context, timer: str, member: discord.Member, *, reason="No reason specified"):
    '''Mutes the specified member Eg: ||?mute @Exploiter <reason for mute>|| where @Exploiter is the person to be muted'''
    muted_role = get(ctx.message.guild.roles, name="Muted")
    if muted_role in member.roles:
        await ctx.send(f"{member.mention} is already muted!!!")
        return
    if user_info.find_one({'id': member.id}) == None:
        x = time.time()
        userDoc = {
            'id': int(member.id),
            'name': str(member),
            'might': 0,
            't1': 0,
            't2': 0,
            't3': 0,
            'potions': 0
        }
        time_Doc = {
            'id': int(member.id), 'beg_time': x, 'resources_time': x, 'fight_time': x, 'scout_time': x, 'profile_time': x, 'potion_time': x, 'train_time': x, 'train_cost_time': x
        }
        user_info.insert_one(userDoc)
        user_time_info.insert_one(time_Doc)
        await asyncio.sleep(1)
    try:

        if(member == bot.user):
            await ctx.send(f"{ctx.author.mention} You can't mute me. How dare u tried to mute me with my power!!!")
            return

        if(member == ctx.author):
            await ctx.send("You can't mute yourself")
            return
        if member.top_role < ctx.author.top_role:
            if not member.bot:
                top = member.top_role
                try:
                    await member.remove_roles(top)
                    await member.add_roles(top)
                except Exception as error:
                    await ctx.send(f"{member.mention} had higher role than me!!")
                    return
            else:
                await ctx.send("Can not mute bot")
                return
            user_info.find_one_and_update(
                {'id': member.id}, {'$push': {'original_roles': {'$each': [i.id for i in member.roles]}}})
            user_info.find_one_and_update(
                {'id': member.id}, {'$set': {'muted_time': time.time()}})
            guild = ctx.guild
            muted_role = discord.utils.get(guild.roles, name="Muted")
            if not muted_role:
                muted_role = await guild.create_role(name="Muted")
                for channel in guild.channels:
                    await channel.set_permissions(muted_role, speak=False, send_messages=False, read_message_history=True, read_messages=True)

            r = member.roles.copy()
            if muted_role in r:
                r.remove(muted_role)
            for r_ in r:
                try:
                    await member.remove_roles(r_)
                except:
                    pass
            await member.add_roles(muted_role, reason=reason)
            # Muting time in seconds
            if(timer[-1] == "s"):
                prefix = "seconds"
                value = 1
            elif(timer[-1] == "m"):
                prefix = "minutes"
                value = 60
            elif(timer[-1] == "h"):
                prefix = "hours"
                value = 60*60
            elif(timer[-1] == "d"):
                prefix = "days"
                value = 60*60*24
            n = len(timer)
            announce_time = timer[0:n-1]
            announce_time = int(announce_time)
            mute_time_in_seconds = announce_time*value
            announce_time = str(announce_time)
            await ctx.send(member.mention+" has been muted for the reason "+reason + " by "+ctx.author.mention)
            await member.send(f"You were muted in the server {guild.name} for {announce_time} {prefix} for reason  {reason}")
            await asyncio.sleep(mute_time_in_seconds)
        else:
            await ctx.reply(f"Can't mute {member.mention}. They had higher role than you ")
            return
        muted_role_check = discord.utils.get(member.roles, name="Muted")
        check_var = 0
        if not muted_role_check:
            try:
                for role_id in user_info.find_one({'id': member.id})['original_roles']:
                    if role_id in [_.id for _ in ctx.guild.roles]:
                        try:
                            await member.add_roles(ctx.guild.get_role(role_id))
                            check_var = check_var+1
                        except:
                            pass
                if(check_var != 0):
                    await member.send(f"{member.mention} You were unmuted in the server {ctx.guild.name}")
            except:
                pass
            finally:
                await member.remove_roles(muted_role)
                user_info.find_one_and_update(
                    {'id': member.id}, {'$pull': {'original_roles': {'$in': [i.id for i in member.roles]}}})
            if(check_var != 0):
                await ctx.send(f"{member.mention} has been unmuted!!!")
        elif member.top_role >= ctx.author.top_role:
            await ctx.send(f"You can't mute{member.mention}.They had higher role than you !!!")
    except Exception as e:
        print(e)
        await ctx.send("Mention a member properly or give me role properly!!!")


@bot.command(description="Unmute the specified user")
@commands.guild_only()
@commands.has_permissions(kick_members=True)
async def unmute(ctx: commands.Context, member: discord.Member):
    '''Unmutes the specified member Eg: ||?unmute @Exploiter|| where @Exploiter is the person to be unmuted'''
    muted_role = get(ctx.message.guild.roles, name="Muted")
    if muted_role not in member.roles:
        await ctx.send(f"{member.mention} is already unmuted!!!")
        return
    if user_info.find_one({'id': member.id}) == None:
        await ctx.send(f'{member.mention} is not in muted state')
        return
    try:
        if(member == bot.user):
            await ctx.send(f"{ctx.author.mention} I am always unmuted.Don't send jokes here!!!")
            return
        if(member == ctx.author):
            await ctx.send("You can't unmute yourself")
            return
        if member.top_role <= ctx.author.top_role:
            muted_role = discord.utils.get(ctx.guild.roles, name="Muted")
            await member.remove_roles(muted_role)
            try:
                check_var1 = 0
                for role_id in user_info.find_one({'id': member.id})['original_roles']:
                    if role_id in [_.id for _ in ctx.guild.roles]:
                        try:
                            user_info.find_one_and_update(
                                {'id': member.id}, {'$pull': {'original_roles': {'$in': [role_id]}}})
                            await member.add_roles(ctx.guild.get_role(role_id))
                            check_var1 = check_var1+1
                        except:
                            pass
                if(check_var1 != 0):
                    await member.send(f"{member.mention} You were unmuted in the server {ctx.guild.name}")
                    await ctx.send(f"{member.mention} has been unmuted by {ctx.author.mention}")
                if(check_var1 == 0):
                    await ctx.send(f"{member.mention} is already in unmuted state")
            except:
                pass

        else:
            await ctx.send(f"You can't unmute{member.mention}.They had higher role than you !!!")
    except:
        await ctx.send("The member is not muted or the member is invalid or no such role exists or give me role properly")


@bot.group(invoke_without_command=True)
async def help(ctx):
    em = discord.Embed(
        title="Help", description="Use ``?help <command>`` for more information of that command ", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Moderation",
                 value="kick,ban,mute,unmute,unban,clear", inline=False)
    em.add_field(name="Giveaway",
                 value="Warning :Need specific role(fixed by ``grole``) to use.commands:greroll,gend,gstart,gcreate,grole", inline=False)
    em.add_field(
        name="Games", value="start,beg,resources,fight,scout,profile,potion,train,train_cost", inline=False)
    em.add_field(
        name="Music", value="join,leave,play,pause,resume,stop,loop,queue,np,skip,volume,remove", inline=False)
    em.add_field(
        name="Fun", value="meme,quote,invite,avatar,hack,aki,caki", inline=False)
    em.add_field(name="Developers", value="close", inline=False)
    await ctx.send(embed=em)


@help.command()
async def kick(ctx):
    em = discord.Embed(
        title="Kick", description="Kicks a member from the server", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(
        name="Syntax:", value="?kick <member> <reason for kick(optional)>", inline=False)
    em.add_field(name="Example:",
                 value="?kick @Exploiter checking", inline=False)
    await ctx.send(embed=em)


@help.command()
async def ban(ctx):
    em = discord.Embed(
        title="Ban", description="Bans a member from the server", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(
        name="Syntax:", value="?ban <member> <reason for ban(optional)>", inline=False)
    em.add_field(name="Example:",
                 value="?ban @Exploiter checking", inline=False)
    await ctx.send(embed=em)


@help.command()
async def mute(ctx):
    em = discord.Embed(
        title="Mute", description="Mutes a member in the server", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(
        name="Syntax:", value="?mute <(Required time to mute in int)+``s-seconds,m-minutes,h-hours,d-days> <reason for mute(optional)>", inline=False)
    em.add_field(name="Example:",
                 value="?mute 10m @Exploiter checking", inline=False)
    await ctx.send(embed=em)


@help.command()
async def unmute(ctx):
    em = discord.Embed(
        title="Unmute", description="Unmutes a member in the server", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(
        name="Syntax:", value="?unmute <member>", inline=False)
    em.add_field(name="Example:",
                 value="?unmute @Exploiter", inline=False)
    await ctx.send(embed=em)


@help.command()
async def unban(ctx):
    em = discord.Embed(
        title="Unban", description="Unbans a member in the server", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(
        name="Syntax:", value="?unban <member> ", inline=False)
    em.add_field(name="Example:",
                 value="?unban @Exploiter", inline=False)
    await ctx.send(embed=em)


@help.command()
async def clear(ctx):
    em = discord.Embed(
        title="Clear", description="Clears the n-number of messages in the channel", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(
        name="Syntax:", value="?clear <amount of messages to be cleared(optional and default=2)>", inline=False)
    em.add_field(name="Example:",
                 value="?clear 100", inline=False)
    await ctx.send(embed=em)


@help.command()
async def gstart(ctx):
    em = discord.Embed(
        title="Gstart", description="Starts the give away in the current channel", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Warning:",
                 value="Need specific role(fixed by ``grole``) to use", inline=False)
    em.add_field(
        name="Syntax:", value="?gstart <(time in int)+``s-seconds,m-minutes,h-hours,d-days``> <(number of winners)+``w``> <prize>", inline=False)
    em.add_field(name="Example:",
                 value="?gstart 1m 1w Coins", inline=False)
    await ctx.send(embed=em)


@help.command()
async def gcreate(ctx):
    em = discord.Embed(
        title="Gcreate", description="Starts the give away in the given channel. Once the qns are answered", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Warning:",
                 value="Need specific role(fixed by ``grole``) to use", inline=False)
    em.add_field(name="Q1 Syntax:",
                 value="<#channel> Eg:``#giveaway``", inline="false")
    em.add_field(name="Q2 Syntax:",
                 value="<(time in int)+``s-seconds,m-minutes,h-hours,d-days``> Eg:``10m``", inline=False)
    em.add_field(name="Q3 Syntax:",
                 value="<Number of winners>. Eg:``2``", inline=False)
    em.add_field(name="Q4 Syntax:",
                 value="<prize of giveaway> Eg:``Coins``", inline=False)
    await ctx.send(embed=em)


@help.command()
async def greroll(ctx):
    em = discord.Embed(
        title="Greroll", description="Reroll the ended giveaway", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Warning:",
                 value="Need specific role(fixed by ``grole``) to use", inline=False)
    em.add_field(
        name="Syntax:", value="?greroll <#channel-name in which the giveaway ended> <id of the ended giveaway>", inline=False)
    em.add_field(name="Example:",
                 value="?greroll #giveaway 897425147110232094", inline=False)
    await ctx.send(embed=em)


@help.command()
async def gend(ctx):
    em = discord.Embed(
        title="Gend", description="Ends the active giveaway", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Warning:",
                 value="Need specific role(fixed by ``grole``) to use", inline=False)
    em.add_field(
        name="Syntax:", value="?gend <#channel-name in which the giveaway is going> <id of the active giveaway>", inline=False)
    em.add_field(name="Example:",
                 value="?gendl #giveaway 897425147110232094", inline=False)
    await ctx.send(embed=em)


@help.command()
async def grole(ctx):
    em = discord.Embed(
        title="Grole", description="Use this command to fix a role for the giveaway", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Syntax:",
                 value="``?grole<@specific_role>``", inline=False)
    em.add_field(name="Example:",
                 value="``?grole @giveaway``", inline=False)
    await ctx.send(embed=em)


@help.command()
async def start(ctx):
    em = discord.Embed(
        title="Start", description="Use this command to start playing the games", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Command:",
                 value="``?start``", inline=False)
    await ctx.send(embed=em)


@help.command()
async def beg(ctx):
    em = discord.Embed(
        title="Beg", description="Use this command to get training potion(Less amount high probability)", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Command:",
                 value="``?beg``", inline=False)
    await ctx.send(embed=em)


@help.command()
async def resources(ctx):
    em = discord.Embed(
        title="Resources", description="Use this command to get training potion(Higher amount less probability)", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Command:",
                 value="``?resources``", inline=False)
    await ctx.send(embed=em)


@help.command()
async def fight(ctx):
    em = discord.Embed(
        title="Fight", description="Use this command to attack other players and gain potions", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Syntax:",
                 value="?fight <Tag other player>", inline=False)
    em.add_field(name="Example:",
                 value="``?fight @EXPLOITER#6889``", inline=False)
    await ctx.send(embed=em)


@help.command()
async def scout(ctx):
    em = discord.Embed(
        title="Scout", description="Used to scout other players might,potions and troop count", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Syntax:",
                 value="?scout <Tag other player>", inline=False)
    em.add_field(name="Example:",
                 value="``?scout @EXPLOITER#6889``", inline=False)
    await ctx.send(embed=em)


@help.command()
async def profile(ctx):
    em = discord.Embed(
        title="Profile", description="Used to see our troops, might and potions count and enemies might", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(
        name="Type1:", value="``?profile``- Sends our troops,potion and might total in dm. If it is blocked it will send in the channel", inline=False)
    em.add_field(name="Type2:",
                 value="?profile <Tag others> Eg:``?profile @EXPLOITER#6889``. Sends enemy might", inline=False)
    await ctx.send(embed=em)


@help.command()
async def potion(ctx):
    em = discord.Embed(
        title="Potion", description="Used to see our potion count", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Command:",
                 value="``?potion``", inline=False)
    await ctx.send(embed=em)


@help.command()
async def train(ctx):
    em = discord.Embed(
        title="Train", description="Used to train troops from tier 1-3", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Syntax:",
                 value="?train <tier> <amount>", inline=False)
    em.add_field(name="Example:", value="``?train 3 1000``")
    await ctx.send(embed=em)


@help.command()
async def train_cost(ctx):
    em = discord.Embed(
        title="Cost and Might of troops", description="Use this command to see the troops might and cost of training", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Command:",
                 value="``?train_cost``", inline=False)
    await ctx.send(embed=em)


@help.command()
async def meme(ctx):
    em = discord.Embed(
        title="Meme", description="Sends a random meme", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Command:",
                 value="``?meme``", inline=False)
    await ctx.send(embed=em)


@help.command()
async def hack(ctx):
    em = discord.Embed(
        title="Hacking", description="Used to hack others", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Syntax:",
                 value="Command: ``?hack @EXPLOITER#6889`` -Sends some hacking messages", inline=False)
    await ctx.send(embed=em)


@help.command()
async def quote(ctx):
    em = discord.Embed(
        title="Quote", description="Sends the quote randomly and for each day", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Type 1:",
                 value="Command: ``?quote`` -Sends a random quote", inline=False)
    em.add_field(name="Type 2:",
                 value="Command: ``?quote today`` -Sends the quote of today", inline=False)
    await ctx.send(embed=em)


@help.command()
async def invite(ctx):
    em = discord.Embed(
        title="Invite", description="Sends the invite link of the bot", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Command:",
                 value="``?invite``", inline=False)
    await ctx.send(embed=em)


@help.command()
async def close(ctx):
    em = discord.Embed(
        title="Close", description="Used to close the bot for updates(Only available for developers)", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Command:",
                 value="``?close``", inline=False)
    await ctx.send(embed=em)


@help.command()
async def avatar(ctx):
    em = discord.Embed(
        title="Avatar", description="Sends the avatar of required one link", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Type 1:",
                 value="Command: ``?avatar`` -Sends our own avatar with link", inline=False)
    em.add_field(name="Type 2:",
                 value="Command: ``?avatar @EXPLOITER#6889`` -Sends the avatar of @EXPLOITER#6889", inline=False)
    await ctx.send(embed=em)


@help.command()
async def aki(ctx):
    desc_helpme = '__**HOW TO PLAY**__\n\nUse the `?aki` command followed by the game mode you want to play. Here is ' \
        'a list of currently available game modes : **people, animals, objects**.\nFor example : `?aki people`\n\n__**GAME MODES**__\n\n' \
        '**People** : This is the game mode for guessing people (fictional or real)\n**Animals** : ' \
        'This is the game mode for guessing animals\n**Objects** : This is the game mode for guessing objects' \
        '\n\n__**MISCELLANEOUS**__\n\n**1.**Wait until all emojis are displayed before adding your reaction, or' \
        ' else it will not register it and you will have to react again once it is done displaying' \
        '\n**2.**The game ends in 45 seconds if you do not answer the question by reacting with the right' \
        ' emoji\n**3.** The bot might sometimes be slow, please be patient and wait for it to ask you the questions. If it is stuck, do not worry the game will automatically end in 30 seconds and you can start playing again\n**4.** Only one person can play at a time\n\n' \
        '__**EMOJI MEANINGS**__\n\n‚úÖ = This emoji means "yes"\n‚ùå = This emoji means "no"\nü§∑ = This emoji means' \
        '"I do not know"\nüëç = This emoji means "probably"\nüëé = This emoji means "probably not"\n‚èÆ = This ' \
        'emoji repeats the question before\nüõë = This emoji ends the game being played'
    embed_var_helpme = discord.Embed(description=desc_helpme, color=0x00FF00)
    embed_var_helpme.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    await ctx.send(embed=embed_var_helpme)


@help.command()
async def caki(ctx):
    em = discord.Embed(
        title="Channel for akinator", description="Use this command to fix the channel for akinator", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Syntax:",
                 value="``?caki<#specific channel>``", inline=False)
    em.add_field(name="Example:",
                 value="``?caki #general``", inline=False)
    await ctx.send(embed=em)


@help.command()
async def join(ctx):
    em = discord.Embed(
        title="Join", description="Use this command to join the bot in voice channel", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Command:",
                 value="``?join``", inline=False)
    await ctx.send(embed=em)


@help.command()
async def leave(ctx):
    em = discord.Embed(
        title="Leave", description="Use this command to leave the bot from voice channel", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Command:",
                 value="``?leave``", inline=False)
    await ctx.send(embed=em)


@help.command()
async def play(ctx):
    em = discord.Embed(
        title="Play", description="Use this command to play a song", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Syntax:",
                 value="``?play <song name>``", inline=False)
    em.add_field(name="Example:",
                 value="``?play arcade``", inline=False)
    await ctx.send(embed=em)


@help.command()
async def pause(ctx):
    em = discord.Embed(
        title="Pause", description="Use this command to pause a song that is playing currently", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Command:",
                 value="``?pause``", inline=False)
    await ctx.send(embed=em)


@help.command()
async def resume(ctx):
    em = discord.Embed(
        title="Resume", description="Use this command to resume the song that is currently paused", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Command:",
                 value="``?resume``", inline=False)
    await ctx.send(embed=em)


@help.command()
async def stop(ctx):
    em = discord.Embed(
        title="Stop", description="Use this command to stop the song that is currently playing", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Command:",
                 value="``?stop``", inline=False)
    await ctx.send(embed=em)


@help.command()
async def loop(ctx):
    em = discord.Embed(
        title="Loop", description="Use this command to loop the song that is currently playing", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Command:",
                 value="``?loop``", inline=False)
    await ctx.send(embed=em)


@help.command()
async def queue(ctx):
    em = discord.Embed(
        title="Queue", description="Used to view the queued song", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Command:",
                 value="``?queue``", inline=False)
    await ctx.send(embed=em)


@help.command()
async def np(ctx):
    em = discord.Embed(
        title="Now-Playing", description="Used to view the currently playing song", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Command:",
                 value="``?np``", inline=False)
    await ctx.send(embed=em)


@help.command()
async def skip(ctx):
    em = discord.Embed(
        title="Skip", description="Used to skip the song and moves to next song in queue", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Command:",
                 value="``?skip``", inline=False)
    await ctx.send(embed=em)


@help.command()
async def volume(ctx):
    em = discord.Embed(
        title="volume", description="Used to fix the volume of the song", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Syntax:",
                 value="``?volume <required percentage(0-200%)>``", inline=False)
    em.add_field(name="Example:",
                 value="``?volume 75``", inline=False)
    await ctx.send(embed=em)


@help.command()
async def remove(ctx):
    em = discord.Embed(
        title="Remove", description="Removes the song in the given index", color=ctx.author.color)
    em.set_thumbnail(
        url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
    em.add_field(name="Syntax:",
                 value="``?remove <index of song in queue>``", inline=False)
    em.add_field(name="Example:",
                 value="``?remove 3`` Used to remove 3rd index", inline=False)
    await ctx.send(embed=em)


bot.run(TOKEN)
