from discord.ext import commands, tasks
import discord
import googletrans
from mongodbs import *
# import translator
from googletrans import Translator
import datetime
import pytz
import asyncio
from random import randint


class Others(commands.Cog, name='other'):

    def __init__(self, bot):
        self.bot = bot
        self.determine_task.start()

    def cog_load(self):
        print("Other was loaded")

    def cog_unload(self):
        self.determine_task.cancel()
        print(f'Other was unloaded')

    @commands.command(aliases=['translate'])
    async def tran(self, ctx, lang, *, args):
        try:
            t = Translator()
            a = t.translate(args, dest=lang)
            if(args == a.text):
                msgID = int(args)
                msg = await ctx.fetch_message(msgID)
                a = t.translate(msg.content, dest=lang)
                await ctx.reply(a.text)
            else:
                await ctx.reply(a.text)
        except:
            await ctx.reply("Can't translate this!")

    @tasks.loop(seconds=60)
    async def determine_task(self):
        IST = pytz.timezone('Asia/Kolkata')
        time_now = (datetime.datetime.now(IST))
        time_now = time_now.strftime('%Y-%m-%d %H:%M:%S')
        all_records = task_info.find()
        for i in all_records:
            if(time_now >= i['date']):
                channel_id = i['id']
                channel = self.bot.get_channel(channel_id)
                task = i['task']
                author = i['author']
                ping = i['ping']
                embed = discord.Embed(
                    title="**⏰⏰Reminder⏰⏰**", description=f"**Requested by {author}**", colour=randint(0, 0xffffff))
                embed.add_field(name="Task", value=f"{task}", inline=False)
                await channel.send(embed=embed)
                await channel.send(f"Don't forget to do the task {ping}")
                task_info.delete_one({"date": i['date']})

    @determine_task.before_loop
    async def before_start(self):
        await self.bot.wait_until_ready()

    @commands.command(aliases=['png'])
    @commands.cooldown(1, 5, commands.BucketType.user)
    async def ping(self, ctx):
        await ctx.send(f'Pong! In {round(self.bot.latency * 1000)} ms')

    @commands.command(name="remember", aliases=['rem', 'rember'])
    @commands.guild_only()
    async def remember(self, ctx):
        channelId = ctx.channel.id
        author = ctx.author
        questions = ["Enter the date with time when i want you to remind the task. Example:``2021-11-09 23:50:41``",
                     "What is the task that i need to remind you at that day?", "Ping the people whom i wanted to ping?"]
        answers = []

        def check_a(m):
            if(m.author == ctx.author and m.channel == ctx.channel):
                return True

        def check_valid_date(date_string: str):
            IST = pytz.timezone('Asia/Kolkata')
            time_now = (datetime.datetime.now(IST))
            time_now = time_now.strftime('%Y-%m-%d %H:%M:%S')
            format = "%Y-%m-%d %H:%M:%S"
            if(len(date_string) != 19):
                return False
            try:
                try:
                    expect_time = str(
                        datetime.datetime.strptime(date_string, format))
                    if(time_now < expect_time):
                        return True
                    else:
                        return False
                except:
                    return False
            except:
                return False

        for i in questions:
            await ctx.send(i)
            try:
                msg = await self.bot.wait_for('message', timeout=120.0, check=check_a)
            except asyncio.TimeoutError:
                await ctx.send("You didn't entered the task on time, please answer at next time!")
                return
            else:
                answers.append(msg.content)

        y = str(answers[0])
        if not(check_valid_date(y)):
            await ctx.send("Enter it in %yyyy %mm %dd hh:mm:ss format. Note:``You can only schedule future tasks!!!``")
            return
        else:
            task_Doc = {
                'date': str(answers[0]), 'id': int(channelId),
                'task': str(answers[1]),
                "author": ctx.author.mention,
                "ping": str(answers[2])
            }
            task_info.insert_one(task_Doc)
            await ctx.reply("I remembered that thing i will let you know on that time!!")

    @commands.command()
    @commands.guild_only()
    async def serverinfo(self, ctx):
        def boost(x: int):
            if(x < 2):
                return "Free"
            elif(x >= 2 and x < 7):
                return "Friends"
            elif(x >= 7 and x < 14):
                return "Groups"
            else:
                return "Communities"

        def chunkify(lst, n):
            return [lst[i::n] for i in range(n)]
        plan = boost(int(ctx.guild.premium_subscription_count))
        role_count = len(ctx.guild.roles)
        list_of_bots = [bot.mention for bot in ctx.guild.members if bot.bot]

        embed2 = discord.Embed(
            timestamp=ctx.message.created_at, colour=randint(0, 0xffffff))
        embed2.add_field(name='Name', value=f"{ctx.guild.name}", inline=False)
        embed2.add_field(name='Owner', value=f"{ctx.guild.owner.name}")
        embed2.add_field(name='Verification Level',
                         value=str(ctx.guild.verification_level))
        embed2.add_field(name='Highest role', value=ctx.guild.roles[-1])
        n = len(ctx.guild.roles)
        splits = int(n/40)+1
        big_list = []
        for i in ctx.guild.roles:
            big_list.append(i.mention)
        x = chunkify(big_list, splits)
        for i in range(splits):
            roles_list = ""
            for j in x[i]:
                roles_list += j+" "
            embed2.add_field(name="Roles", value=roles_list)
        embed2.add_field(name='Created At', value=ctx.guild.created_at.__format__(
            '%A, %d. %B %Y @ %H:%M:%S'), inline=False)
        embed2.add_field(name='Joined', value=ctx.author.joined_at.__format__(
            '%A, %d. %B %Y @ %H:%M:%S'), inline=False)
        embed2.add_field(name='Number of roles', value=str(role_count))
        embed2.add_field(name='Number Of Members',
                         value=ctx.guild.member_count, inline=True)
        embed2.add_field(name='ServerId', value=ctx.guild.id, inline=True)
        embed2.add_field(name='Region', value=ctx.guild.region, inline=True)
        embed2.add_field(name="Boosts count",
                         value=ctx.guild.premium_subscription_count)
        embed2.add_field(name="Server Plan", value=plan)
        embed2.add_field(name='Bots:', value=(
            ', '.join(list_of_bots)), inline=False)
        embed2.set_thumbnail(url=ctx.guild.icon_url)
        embed2.set_author(name=ctx.author.name, icon_url=ctx.author.avatar_url)
        embed2.set_footer(text=self.bot.user.name,
                          icon_url=self.bot.user.avatar_url)
        await ctx.send(embed=embed2)

    @commands.command(name="info")
    @commands.guild_only()
    async def info(self, ctx, *, user: discord.Member = None):  # b'\xfc'
        if user is None:
            user = ctx.author
        date_format = "%a, %d %b %Y %I:%M %p"
        embed = discord.Embed(colour=randint(
            0, 0xffffff), description=user.mention)
        embed.set_author(name=str(user), icon_url=user.avatar_url)
        embed.set_thumbnail(url=user.avatar_url)
        embed.add_field(
            name="Joined", value=user.joined_at.strftime(date_format))
        members = sorted(ctx.guild.members, key=lambda m: m.joined_at)
        embed.add_field(name="Join position", value=str(members.index(user)+1))
        person = self.bot.get_user(user.id)

        embed.add_field(name="Registered",
                        value=person.created_at.strftime(date_format))
        if len(user.roles) > 1:
            role_string = ' '.join([r.mention for r in user.roles][1:])
            embed.add_field(name="Roles [{}]".format(
                len(user.roles)-1), value=role_string, inline=False)
        perm_string = ', '.join([str(p[0]).replace("_", " ").title()
                                for p in user.guild_permissions if p[1]])
        embed.add_field(name="Guild permissions",
                        value=perm_string, inline=False)
        # list_roles=""
        badge_class = str(user.public_flags.all()).replace('[<UserFlags.', '').replace('>]', '').replace('_',
                                                                                                         ' ').replace(
            ':', '').title()
        badge_class = ''.join([i for i in badge_class if not i.isdigit()])
        embed.add_field(name="Badges", value=badge_class)
        embed.set_footer(text='ID: ' + str(user.id))
        return await ctx.send(embed=embed)


def setup(bot):
    bot.add_cog(Others(bot))
    print(f'Other was loaded!')
