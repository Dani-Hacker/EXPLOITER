import json
import discord
from random import randint
from discord.ext import commands
from mongodbs import *
from discord.ext.commands import cooldown, BucketType
import asyncio
from discord.utils import get
    
class Ticket(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
    
        
    @commands.command()
    @commands.has_permissions(administrator=True)
    @commands.cooldown(1, 3, commands.BucketType.user)
    async def ticketmention(self,ctx,*args):
      try:
        serverId = ctx.message.guild.id    
        if server_info.find_one({'id': serverId}):
          try:
            x=list(server_info.find({ "id":serverId }))[0]['disabled']
            if "ticketmention" in x:
              return
          except:
            pass
        serverId=int(ctx.message.guild.id)
        mentions=list(args)
        ids=[]
        for i in mentions:
          n=len(i)
          ids.append(int(i[3:n-1]))
        for j in ids:
          role = get(ctx.guild.roles, id=j)

        if ticket_info.find_one({'id': serverId}):
            ticket_info.update_one({'id': serverId}, {
                    '$set': {'mentions': mentions}})
            await ctx.reply(f"You fixed {mentions} for mentioning ticket creator in your server")
        else:
          server_Doc = {
                  'id': int(serverId)
                  ,'mentions':mentions
              }
          ticket_info.insert_one(server_Doc)   
          await ctx.reply(f"You fixed {mentions} for mentioning ticket creator in your server")
        await asyncio.sleep(3)
        await ctx.channel.purge(limit=2)
      except:
        await ctx.reply("Please mention only roles")


    @commands.command()
    @commands.has_permissions(administrator=True)
    @commands.cooldown(1, 4, commands.BucketType.user)
    async def createticket(self, ctx, *args):
        serverId = ctx.message.guild.id    
        if server_info.find_one({'id': serverId}):
          try:
            x=list(server_info.find({ "id":serverId }))[0]['disabled']
            if "createticket" in x:
              return
          except:
            pass
        if ticket_info.find_one({'id': serverId}):
          pass
        else:
            await ctx.reply(f"Please use ``?ticketmention`` command to know me what to mention?")
            return
        format_args = list(args)

        guild_id = ctx.message.guild.id
        channel_id = int(format_args[0].strip('<').strip('>').replace('#', ''))
        title = ' '.join(format_args[1:])
    

        # Create new embed with reaction
        ticket_embed = discord.Embed(colour=randint(0, 0xffffff))
        ticket_embed.set_thumbnail(
            url=f'https://cdn.discordapp.com/icons/{guild_id}/{ctx.message.guild.icon}.png')

        ticket_embed.add_field(name=f'Welcome To {ctx.message.guild} Server', value=f'{title}')
        ticket_embed.set_footer(text="React to create ticket without cluster")
        send_ticket_embed = await self.bot.get_channel(channel_id).send(embed=ticket_embed)

        await send_ticket_embed.add_reaction(u'\U0001F3AB')
        
        with open('.//databases//ticket.json', 'r') as file:
            ticket_data = json.load(file)
            new_ticket = str(guild_id)

            # Update existing ticket
            if new_ticket in ticket_data:
                ticket_data[new_ticket] = [channel_id]
                with open('.//databases//ticket.json', 'w') as update_ticket_data:
                    json.dump(ticket_data, update_ticket_data, indent=4)

            # Add new ticket
            else:
                ticket_data[new_ticket] = [channel_id]
                with open('.//databases//ticket.json', 'w') as new_ticket_data:
                    json.dump(ticket_data, new_ticket_data, indent=4)

    @commands.command()
    @commands.cooldown(1, 3, commands.BucketType.user)
    async def closeticket(self, ctx, mentioned_user:discord.Member):
      serverId = ctx.message.guild.id    
      if server_info.find_one({'id': serverId}):
        try:
          x=list(server_info.find({ "id":serverId }))[0]['disabled']
          if "closeticket" in x:
            return
        except:
          pass
      try:
        try:
          name_role=discord.utils.get(ctx.message.guild.roles,name=mentioned_user.name)
          if name_role in ctx.author.roles:
            await ctx.reply(f"Ticket creators can't close this ticket!")
            return
        except:
          await ctx.reply("Mention the user properly")  
          return       
        channel_name=ctx.channel.name
        channel_name=channel_name[2:len(channel_name)]
        user_name=mentioned_user.name.lower().replace(" ","-")
        if channel_name==user_name:
          pass
        else:
          await ctx.reply("Try running it in correct channel")
          return  
        if name_role in mentioned_user.roles:
            await name_role.delete(reason='Removed by command')
            await ctx.message.channel.delete(reason=None)
      except:
          await ctx.reply(f"Please mention the member properly in the ticket-created channel")
          return

    @commands.command()
    @commands.guild_only()
    @commands.has_permissions(administrator=True)
    @commands.cooldown(1, 3, commands.BucketType.user)
    async def dropticket(self,ctx): 
      serverId = ctx.message.guild.id    
      if server_info.find_one({'id': serverId}):
        try:
          x=list(server_info.find({ "id":serverId }))[0]['disabled']
          if "dropticket" in x:
            return
        except:
          pass
      try:
        guild_id = ctx.message.guild.id
        with open('.//databases//ticket.json', 'r') as data_file:
            data = json.load(data_file)
        data.pop(str(guild_id), None)
        with open('.//databases//ticket.json', 'w') as data_file:
            data = json.dump(data, data_file)
        await ctx.reply("Ticket in this server has been dropped")  
      except:
        await ctx.reply("You didn't created any tickets before! :thinking:")    
          

    @commands.Cog.listener()
    async def on_raw_reaction_add(self, payload):
      try:
        if payload.member.id != self.bot.user.id:
            with open('.//databases//ticket.json', 'r') as file:
                ticket_data = json.load(file)

            channel_id = list(ticket_data.values())
            user_channel_id = payload.channel_id

            for items in channel_id:
                if user_channel_id in items:
                    # Get guild and roles
                    find_guild = discord.utils.find(lambda guild: guild.id == payload.guild_id, self.bot.guilds)
                    guild_roles = discord.utils.get(find_guild.roles, name=f'{payload.member.name}')

                    if guild_roles is None:
                        # Create new role
                        permissions = discord.Permissions(send_messages=True, read_messages=True)
                        await find_guild.create_role(name=f'{payload.member.name}', permissions=permissions)

                    # Assign new role
                    new_user_role = discord.utils.get(find_guild.roles, name=f'{payload.member.name}')
                    await payload.member.add_roles(new_user_role, reason=None, atomic=True)
                    x=list(ticket_info.find({ "id": int(payload.guild_id)}))[0]['mentions']
                    roles=[]
                    try:
                      for i in x:
                        roles.append(int(i.strip("<@&>")))
                      names=[]
                      for i in roles:
                          names.append(get(find_guild.roles,id=i))
                    except:
                      pass

                    overwrites = {
                        find_guild.default_role: discord.PermissionOverwrite(read_messages=False),
                        new_user_role: discord.PermissionOverwrite(read_messages=True)
                    }
                    for i in names:
                      overwrites[i]=discord.PermissionOverwrite(read_messages=True)
                    # Create new channel
                    create_channel = await find_guild.create_text_channel(
                        u'\U0001F4CB-{}'.format(new_user_role), overwrites=overwrites)
                    string_mentions=""
                    for i in x:
                      string_mentions+=str(i)+" "
                    await create_channel.send(
                        f'{new_user_role.mention} Your ticket has been created! Please wait for '
                        f'{string_mentions} to respond!!!.')
      except:
        await create_channel.send("Try removing roles with the user-name already exists")

def setup(bot):
    # asyncio.sleep(1)
    bot.add_cog(Ticket(bot))
    print("ticket was loaded")