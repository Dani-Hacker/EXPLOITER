from discord.ext import commands
import discord
import random
import json
from mongodbs import *
import requests
from truth_dare import truths, dares
import random
from discord.ext.commands import cooldown, BucketType
import asyncio
import bson
from discord_components import *
from random import randint
from discord.utils import get
import wikipedia
import aiohttp
import bs4
from math import *
import re
from urllib import parse, request
from discord_components import (
    Button,
    ButtonStyle,
    Select,
    SelectOption,
    Interaction
)


class funs(commands.Cog, name='fun'):

    def __init__(self, bot):
        self.bot = bot

    def cog_load(self):
        print("loaded")

    def cog_unload(self):
        print(f'Fun was unloaded')

    @commands.command()
    @commands.guild_only()
    @commands.cooldown(1, 3, commands.BucketType.user)
    async def emojify(self, ctx, *, text):
        serverId = ctx.message.guild.id
        emojis = []
        for s in text.lower():
            if s.isdecimal():
                num2emo = {'0': 'zero', '1': 'one', '2': 'two', '3': "three", '4': 'four',
                           '5': 'five', '6': 'six', '7': 'seven', '8': 'eight', '9': 'nine'}
                emojis.append(f":{num2emo.get(s)}:")
            elif s.isalpha():
                emojis.append(f":regional_indicator_{s}:")
            else:
                emojis.append(s)
        await ctx.send(''.join(emojis))

    @commands.command(aliases=['me'])
    @commands.guild_only()
    @commands.cooldown(1, 3, commands.BucketType.user)
    async def meme(self, ctx):
        serverId = ctx.message.guild.id

        def meme_opt():
            choices = [1, 2]
            chosen = random.choice(choices)
            if(chosen == 1):
                '''Post a meme'''
                r = requests.get("https://memes.blademaker.tv/api?lang=en")
                res = r.json()
                title = res["title"]
                ups = res["ups"]
                # downs = res["downs"]
                comments = res['score']
                authors = res["author"]
                memes = discord.Embed(
                    title=f"{title}", colour=randint(0, 0xffffff))
                memes.set_image(url=res["image"])
                memes.set_footer(
                    text=f"üëç : {ups}  ‚úçÔ∏è : {authors}   üí¨ : {comments} ")
            else:
                ###################
                r = requests.get("https://meme-api.herokuapp.com/gimme")
                res = r.json()
                title = res["title"]
                ups = res["ups"]
                author = res["author"]
                link = res["postLink"]
                memes = discord.Embed(
                    description=f"[{title}]({link})", colour=randint(0, 0xffffff))
                memes.set_image(url=res["url"])
                memes.set_footer(text=f"üëç : {ups} ‚úçÔ∏è : {author}")
            return memes

        components = [
            [
                Button(label='Next meme',
                       style=ButtonStyle.green, custom_id='next'),
                Button(label='End interaction',
                       style=ButtonStyle.red, custom_id='exit')
            ]
        ]

        message = await ctx.send(embed=meme_opt(), components=components)
        id = message.id
        while True:
            try:
                interaction = await self.bot.wait_for(
                    'button_click',
                    check=lambda inter: inter.message.id == message.id,
                    timeout=30
                )
            except asyncio.TimeoutError:
                for row in components:
                    row.disable_components()
                return await message.edit(components=components)

            if(interaction.author.id == ctx.author.id):
                if(interaction.custom_id == "next"):
                    await interaction.edit_origin(embed=meme_opt(), components=components)
                elif(interaction.custom_id == "exit"):
                    for row in components:
                        row.disable_components()
                    message = await ctx.fetch_message(id)
                    return await interaction.edit_origin(embed=message.embeds[0], components=components)
            else:
                await interaction.send("Hey! This is not for you!")

    @commands.command()
    @commands.guild_only()
    @commands.cooldown(1, 3, commands.BucketType.user)
    async def fact_cat(self, ctx):
        serverId = ctx.message.guild.id
        '''Post a cat fact'''
        r = requests.get("https://catfact.ninja/fact")
        res = r.json()
        embed = discord.Embed(title=f"Did you know this cat-fact?",
                              description=res["fact"], colour=randint(0, 0xffffff))
        return await ctx.send(embed=embed)

    @commands.command()
    @commands.guild_only()
    @commands.cooldown(1, 3, commands.BucketType.user)
    async def dog(self, ctx):
        serverId = ctx.message.guild.id
        '''Post a cat fact'''
        r = requests.get("https://dog.ceo/api/breeds/image/random")
        res = r.json()
        embed = discord.Embed(
            title=f"Have you seen this dog?", colour=randint(0, 0xffffff))
        embed.set_image(url=res["message"])
        return await ctx.send(embed=embed)

    @commands.command()
    @commands.guild_only()
    @commands.cooldown(1, 5, commands.BucketType.user)
    @commands.has_permissions(kick_members=True)
    async def count_channel(self, ctx, target_channel):
        try:
            serverId = ctx.message.guild.id
            if not count_info.find_one({'id': serverId}):
                c_id = int(target_channel[2:-1])
                # chan=get(ctx.guild.text_channels,id=c_id)
                channel = self.bot.get_channel(c_id)
                value = 1
                person_id = self.bot.user.id
                await ctx.send(f"{ctx.author.mention} You successfully fixed {target_channel} as count channel!")
                embed = discord.Embed(title="From now on this channel is announced as count channel :partying_face::partying_face:",
                                      description="Let me start the counting in the counting channel!!!", colour=randint(0, 0xffffff))
                await channel.send(embed=embed)
                embed1 = discord.Embed(
                    title=value, colour=randint(0, 0xffffff))
                x = await channel.send(embed=embed1)
                await x.add_reaction("‚úÖ")
                userDoc = {
                    'id': serverId,
                    'c_id': c_id,
                    'value': bson.Int64(1),
                    'last_sender': person_id,
                    'msg_id': bson.Int64(12343)
                }
                count_info.insert_one(userDoc)
            else:
                await ctx.reply("You already started this counting game  in this server!")
                await ctx.reply("use ``?change_count`` for change the continuation of count in other channel\n``?count_reset``for resetting the count value from beginning\n``?cancel_count`` to cancel this counting game in ur server ")
        except:
            await ctx.reply("No such channel exist")

    @commands.command()
    @commands.guild_only()
    @commands.cooldown(1, 5, commands.BucketType.user)
    @commands.has_permissions(administrator=True)
    async def count_reset(self, ctx):
        serverId = ctx.message.guild.id
        try:
            existed_id = int(count_info.find_one(
                {'id': serverId})['c_id'])
            if(ctx.message.channel.id != existed_id):
                count_info.update_one({'id': serverId}, {
                    '$set': {'value': bson.Int64(1), "last_sender": self.bot.user.id}})
                channel = get(ctx.guild.text_channels, id=existed_id)
                await ctx.reply(f"{ctx.author.mention} You resetted{channel.mention} counting successfully!")
                embed = discord.Embed(title=f"‚ö†Ô∏è‚ö†Ô∏èThe counting in this channel has been resetted by {ctx.author,name}‚ö†Ô∏è‚ö†Ô∏è",
                                      description="Let me start the counting in the counting channel!!!", colour=randint(0, 0xffffff))
                await channel.send(embed=embed)
                embed1 = discord.Embed(title=1, colour=randint(0, 0xffffff))
                x = await channel.send(embed=embed1)
                await x.add_reaction("‚úÖ")
        except:
            await ctx.reply("You didn't fixed any counting channel yet!!")

    @commands.command()
    @commands.guild_only()
    @commands.cooldown(1, 5, commands.BucketType.user)
    async def current_count(self, ctx):
        serverId = ctx.message.guild.id
        if count_info.find_one({'id': serverId}):
            stored_info = count_info.find_one(
                {'id': serverId})
            existed_id = int(stored_info['c_id'])
            channel = get(ctx.guild.text_channels, id=existed_id)
            value = int(stored_info['value'])
            last_sender = int(stored_info['last_sender'])
            person = await ctx.message.guild.fetch_member(last_sender)
            embed = discord.Embed(
                title="Last count:", description=f"Last count was {str(value)} counted by {person.mention}. This was requested by {ctx.author.mention}", timestamp=ctx.message.created_at, colour=randint(0, 0xffffff))
            embed.set_thumbnail(
                url="https://cdn.discordapp.com/avatars/839421874646548530/0c3f5a2ee26def577afe60154cd106cd.webp?size=1024")
            await ctx.send(embed=embed)
        else:
            await ctx.reply("There is no counting channel in this server!!!")

    @commands.command()
    @commands.guild_only()
    @commands.cooldown(1, 5, commands.BucketType.user)
    @commands.has_permissions(administrator=True)
    async def cancel_count(self, ctx):
        serverId = ctx.message.guild.id
        if count_info.find_one({'id': serverId}):
            existed_id = int(count_info.find_one(
                {'id': serverId})['c_id'])
            channel = get(ctx.guild.text_channels, id=existed_id)
            embed = discord.Embed(
                title=f"{ctx.author.name} Stopped the counting game", colour=randint(0, 0xffffff))
            await channel.send(embed=embed)
            count_info.delete_one({'id': serverId})
            await ctx.reply(f"{ctx.author.mention} Counting game has been stopped!")
        else:
            await ctx.reply("There is no counting channel in this server!!!")

    @commands.command()
    @commands.guild_only()
    @commands.cooldown(1, 5, commands.BucketType.user)
    @commands.has_permissions(administrator=True)
    async def change_count(self, ctx, target_channel):
        try:
            serverId = ctx.message.guild.id
            if count_info.find_one({'id': serverId}):
                try:
                    message_db = count_info.find_one(
                        {'id': serverId})
                    c_id = int(target_channel[2:-1])
                    old_cid = int(message_db['c_id'])
                    value = int(message_db['value'])
                    channel = self.bot.get_channel(c_id)
                    person_id = self.bot.user.id
                    try:
                        old_chan = get(ctx.guild.text_channels, id=old_cid)
                        await ctx.send(f"{ctx.author.mention} You successfully changed counting from {old_chan.mention} to  {target_channel}")
                    except:
                        await ctx.send(f"{ctx.author.mention} You successfully changed {target_channel} as counting channel")
                    embed = discord.Embed(title="From now on this channel is announced as count channel :partying_face::partying_face:",
                                          description="Let me counting the counting in this channe from where it is stoppedl!!!", colour=randint(0, 0xffffff))
                    embed.add_field(
                        name=f"Last counting in the {old_chan.name}", value=f"{value}")
                    await channel.send(embed=embed)
                    new_value = value+1
                    embed1 = discord.Embed(
                        title=new_value, colour=randint(0, 0xffffff))
                    x = await channel.send(embed=embed1)
                    await x.add_reaction("‚úÖ")
                    embed2 = discord.Embed(
                        title=f"{ctx.author.name} Stopped the counting in this channel and shifted it to {channel.name} channel", colour=randint(0, 0xffffff))
                    await old_chan.send(embed=embed2)
                    count_info.update_one({'id': serverId}, {
                        '$set': {'value': bson.Int64(new_value), "last_sender": person_id, "c_id": c_id}})
                except:
                    await ctx.reply("There is not counting channel in this server! or invalid channel")
            else:
                await ctx.reply("You didn't started counting channel yet!!!")

        except:
            await ctx.reply("No such channel exist")

    @commands.command(aliases=['wiki'])
    @commands.guild_only()
    async def wikipedia(self, ctx, *, arg):
        serverId = ctx.message.guild.id
        input = arg
        await ctx.send(f'<{wikipedia.page(input).url}>')
        await ctx.send(wikipedia.summary(input, sentences=3, auto_suggest=True, redirect=True))

    @commands.command(aliases=['you'])
    @commands.guild_only()
    async def youtube(self, ctx, *, search):
        serverId = ctx.message.guild.id
        query_string = parse.urlencode({'search_query': search})
        html_content = request.urlopen(
            'http://www.youtube.com/results?' + query_string)
        search_content = html_content.read().decode()
        search_results = re.findall(r'\/watch\?v=\w+', search_content)
        await ctx.send('https://www.youtube.com' + search_results[0])

    @commands.Cog.listener()
    async def on_message_edit(self, before, after):
        try:
            serverId = before.guild.id
        except:
            return
        try:
            message_db = count_info.find_one(
                {'id': serverId})
            sent_channel_id = int(before.channel.id)
            msg_id = before.id
            if(int(message_db['c_id']) == sent_channel_id and int(message_db['msg_id']) == msg_id):
                channel = self.bot.get_channel(sent_channel_id)
                msg = await channel.fetch_message(msg_id)
                await msg.delete()
            else:
                return
        except:
            pass

    @commands.Cog.listener()
    async def on_message_delete(self, message):
        serverId = message.guild.id
        try:
            message_db = count_info.find_one(
                {'id': serverId})
            sent_channel_id = int(message.channel.id)
            msg_id = message.id
            if(int(message_db['c_id']) == sent_channel_id and int(message_db['msg_id']) == msg_id):
                try:
                    value = int(message_db['value'])
                    last_sender = int(message_db['last_sender'])
                    member = await message.guild.fetch_member(last_sender)
                    channel = self.bot.get_channel(sent_channel_id)
                    x = await channel.send(f"Last count is {str(value)} sent by {member.mention}")
                    count_info.update_one({'id': serverId}, {
                        '$set': {"msg_id": int(x.id)}})
                    await x.add_reaction("‚úÖ")

                except:
                    return
            else:
                return
        except:
            pass

    @commands.Cog.listener()
    async def on_message(self, message):
        try:
            serverId = message.guild.id
        except:
            return
        if message.author == self.bot.user:
            return
        try:
            message_db = count_info.find_one(
                {'id': serverId})
            sent_channel_id = int(message.channel.id)
            if(int(message_db['c_id']) == sent_channel_id):
                try:

                    message_content = message.content
                    message_content = message_content.replace("^", "**")
                    message_content = message_content.replace("œÄ", "pi")
                    message_content = message_content.replace("‚àö", "sqrt")
                    message_content = float(eval(message_content))
                    value = int(message_db['value'])
                    value = value+1
                    last_sender = int(message_db['last_sender'])
                    sender_id = int(message.author.id)
                    message_id = message.id
                    if((int(value) == message_content) and (sender_id != last_sender)):
                        count_info.update_one({'id': serverId}, {
                            '$set': {'value': bson.Int64(value), "last_sender": sender_id, "msg_id": message_id}})
                        await message.add_reaction("‚úÖ")
                        return
                    else:
                        await message.delete()
                        return
                except:
                    await message.delete()
                    return
            else:
                return
        except:
            pass

    @commands.command()
    @commands.guild_only()
    @commands.cooldown(1, 5, commands.BucketType.user)
    async def ip(self, ctx, ip_address: str):
        serverId = ctx.message.guild.id
        try:
            r = requests.get(f"https://ipinfo.io/{ip_address}/geo")
            res = r.json()
            embed = discord.Embed(
                title=f"Random ip-address", description=res["ip"], colour=randint(0, 0xffffff))
            embed.add_field(name="City", value=res["city"], inline=False)
            embed.add_field(name="Region", value=res["region"], inline=False)
            embed.add_field(name="Country", value=res["country"], inline=False)
            embed.add_field(name="Location", value=res["loc"], inline=False)
            embed.add_field(name="Organisation",
                            value=res["org"], inline=False)
            embed.add_field(name="Postal-number",
                            value=res["postal"], inline=False)
            embed.set_footer(text=f"Timezone: {res['timezone']}")
            return await ctx.send(embed=embed)
        except:
            embed = discord.Embed(title=f"Ip address will be in the format",
                                  description="117.200.149.23", colour=randint(0, 0xffffff))
            embed.add_field(name="Example Command:",
                            value="?ip 117.200.149.23")
            embed.set_footer(
                text=f"Change the number in the ip address to see actually what exists in that address")
            return await ctx.send(embed=embed)

    @commands.command()
    @commands.guild_only()
    @commands.cooldown(1, 3, commands.BucketType.user)
    async def bored(self, ctx):
        serverId = ctx.message.guild.id
        '''Post a cat fact'''
        r = requests.get("https://www.boredapi.com/api/activity")
        res = r.json()
        embed = discord.Embed(title=f"Try this to get away from :sleeping: :sleeping:",
                              description=res["activity"], colour=randint(0, 0xffffff))
        embed.set_footer(text=f"Type :  {res['type']}")
        return await ctx.send(embed=embed)

    @commands.command(aliases=['8ball', 'eightball'])
    @commands.guild_only()
    @commands.cooldown(1, 5, commands.BucketType.user)
    async def eball(self, ctx, *, search):
        serverId = ctx.message.guild.id
        allowed = True
        if(allowed == True):
            emoji = ["üòÇ", "üòï", "üòí", "üò≥", "üò±", "üòû", "ü§î",
                     "üòè", "üôÉ", "üòã", "üò∑", "üòå", "üò¨", "üòé", "üò©"]
            answers = ["Signs point to yes ", "Better not tell you now ", " It is certain ", " You may rely on it ", "No ", "Cannot predict now ", "Outlook not so good ", " My reply is no ", "Nope ",
                       "As I see it, yes ", "It is decidedly so", "Yes", "Most likely", "That's a decision for you to figure out", "My sources say no ", "Nope", "Yep", "Yes - definitely", "No - definitely", "Don't count on it "]
            embed = discord.Embed(
                description=f":8ball: {random.choice(answers)} {random.choice(emoji)}", colour=randint(0, 0xffffff))
            await ctx.send(embed=embed)

    @commands.command(aliases=['tru'])
    @commands.guild_only()
    @commands.cooldown(1, 5, commands.BucketType.user)
    async def truth(self, ctx):
        serverId = ctx.message.guild.id
        allowed = True
        if(allowed == True):
            def truth_opt():
                embed = discord.Embed(
                    title=f'{random.choice(truths)}', description="Note: Your answers won't be visible to anyone :wink: ",
                    colour=randint(0, 0xffffff))
                embed.set_footer(
                    text="If it is not yes or no format then type in chat ")
                return embed
            components = [
                [
                    Button(label='Next question',
                           style=ButtonStyle.green, custom_id='next'),
                    Button(label='End interaction',
                           style=ButtonStyle.red, custom_id='end')
                ],
                [
                    Button(label='Yes', style=ButtonStyle.green, custom_id='yes'),
                    Button(label="Won't say",
                           style=ButtonStyle.blue, custom_id='ws'),
                    Button(label="Don't know",
                           style=ButtonStyle.gray, custom_id='dk'),
                    Button(label="Not interested to answer",
                           style=ButtonStyle.blue, custom_id='ni'),
                    Button(label='No', style=ButtonStyle.red, custom_id='no')
                ]
            ]

            message = await ctx.send(embed=truth_opt(), components=components)
            id = message.id

            while True:
                try:
                    interaction = await self.bot.wait_for(
                        'button_click',
                        check=lambda inter: inter.message.id == message.id,
                        timeout=30
                    )
                except asyncio.TimeoutError:
                    for row in components:
                        row.disable_components()
                    return await message.edit(components=components)

                if ctx.author.id == interaction.author.id:
                    if interaction.custom_id == "next":
                        await interaction.edit_origin(embed=truth_opt(), components=components)
                    elif interaction.custom_id == "end":
                        for row in components:
                            row.disable_components()
                        message = await ctx.fetch_message(id)
                        return await interaction.edit_origin(embed=message.embeds[0], components=components)
                    elif interaction.custom_id == "yes":
                        new_embed = discord.Embed(
                            description=f"You selected ``yes`` option. We hope you answered honstly!", color=discord.Color.green())
                        await interaction.send(embed=new_embed)
                    elif interaction.custom_id == "no":
                        new_embed = discord.Embed(
                            description=f"You selected ``no`` option. We hope you answered honstly!", color=discord.Color.red())
                        await interaction.send(embed=new_embed)
                    elif interaction.custom_id == "dk":
                        new_embed = discord.Embed(
                            description=f"You selected ``Don't know`` option. Think it over for another time")
                        await interaction.send(embed=new_embed)
                    elif interaction.custom_id == "ws":
                        new_embed = discord.Embed(
                            description=f"You selected ``Won't say`` option. If it is yes or no otpion you can say No-one knows what you said", color=discord.Color.gold())
                        await interaction.send(embed=new_embed)
                    elif interaction.custom_id == "ni":
                        new_embed = discord.Embed(
                            description=f"You selected ``Not interested to answer`` option. You can skip to next question if you don't want to answer", color=discord.Color.gold())
                        await interaction.send(embed=new_embed)
                else:
                    await interaction.send(f'This is not for you!')

    @commands.command(aliases=['dru'])
    @commands.guild_only()
    @commands.cooldown(1, 3, commands.BucketType.user)
    async def dare(self, ctx):
        serverId = ctx.message.guild.id
        allowed = True
        if(allowed == True):
            def dare_opt():
                embed = discord.Embed(
                    title=f'{random.choice(dares)}', description="Note: Your answers won't be visible to anyone :wink: ",
                    colour=randint(0, 0xffffff))
                embed.set_footer(
                    text="If you can't answer the question by button then type in chat")
                return embed
            components = [
                [
                    Button(label='Next question',
                           style=ButtonStyle.green, custom_id='next'),
                    Button(label='End interaction',
                           style=ButtonStyle.red, custom_id='end')
                ],
                [
                    Button(label='Done', style=ButtonStyle.green,
                           custom_id='Done'),
                    Button(label="Won't do",
                           style=ButtonStyle.blue, custom_id='wd'),
                    Button(label="May be later",
                           style=ButtonStyle.gray, custom_id='ml'),
                    Button(label="Not interested to do that",
                           style=ButtonStyle.blue, custom_id='ni'),
                    Button(label='Not yet',
                           style=ButtonStyle.red, custom_id='not')
                ]
            ]

            message = await ctx.send(embed=dare_opt(), components=components)
            id = message.id

            while True:
                try:
                    interaction = await self.bot.wait_for(
                        'button_click',
                        check=lambda inter: inter.message.id == message.id,
                        timeout=60
                    )
                except asyncio.TimeoutError:
                    for row in components:
                        row.disable_components()
                    return await message.edit(components=components)

                if ctx.author.id == interaction.author.id:
                    if interaction.custom_id == "next":
                        await interaction.edit_origin(embed=dare_opt(), components=components)
                    elif interaction.custom_id == "end":
                        for row in components:
                            row.disable_components()
                        message = await ctx.fetch_message(id)
                        return await interaction.edit_origin(embed=message.embeds[0], components=components)
                    elif interaction.custom_id == "Done":
                        new_embed = discord.Embed(
                            description=f"You selected ``Done`` option. Awesome dude!", color=discord.Color.green())
                        await interaction.send(embed=new_embed)
                    elif interaction.custom_id == "not":
                        new_embed = discord.Embed(
                            description=f"You selected ``Not yet`` option. Reply me after you done", color=discord.Color.red())
                        await interaction.send(embed=new_embed)
                    elif interaction.custom_id == "ml":
                        new_embed = discord.Embed(
                            description=f"You selected ``May be later`` option. It would be fine if u do now")
                        await interaction.send(embed=new_embed)
                    elif interaction.custom_id == "wd":
                        new_embed = discord.Embed(
                            description=f"You selected ``Won't do`` option. :cry: It would be nice if you do that :rofl: ", color=discord.Color.gold())
                        await interaction.send(embed=new_embed)
                    elif interaction.custom_id == "ni":
                        new_embed = discord.Embed(
                            description=f"You selected ``Not interested to do`` option. Then its your wish. Be what u r :sunglasses: ", color=discord.Color.gold())
                        await interaction.send(embed=new_embed)
                else:
                    await interaction.send(f'This is not for you!')

    @commands.command(aliases=['av', 'ava'])
    @commands.guild_only()
    @commands.cooldown(1, 3, commands.BucketType.user)
    async def avatar(self, ctx: commands.Context, member: discord.Member = None):
        serverId = ctx.message.guild.id
        allowed = True
        if(allowed == True):
            if(member == None):
                await ctx.send(ctx.author.avatar_url)
            else:
                try:
                    await ctx.send(member.avatar_url)
                except:
                    await ctx.send("Mention someone properly!!!")

    @commands.command(aliases=['hck'])
    @commands.guild_only()
    @commands.cooldown(1, 25, commands.BucketType.user)
    async def hack(self, ctx: commands.Context, member: discord.Member):
        serverId = ctx.message.guild.id
        allowed = True
        if(allowed == True):
            if(member == ctx.author):
                await ctx.send(f"I thought not to hack you my friend {member.mention} !. Since you insisted i started hacking you!!!")
                await asyncio.sleep(2)
            if(member == self.bot.user):
                await ctx.send("I am the Hacker üé≠ who hacks everyone. You tried to mess with me so i started hacking your system now üíÄüíÄ‚åõ‚åõ")
                await asyncio.sleep(2)
                member = ctx.author
            my_msg = await ctx.send(f"Started hacking..... {member.mention}")
            x = random.randint(0, 1000)
            texts = ["Collecting sensitive information ‚ö†Ô∏è from phishing once done on you... ",
                     "Launching Malware ‚ò£Ô∏è attacks on you !!",
                     "Injecting ransware and pegasus in your system üëæüëæ üëæ ",
                     "Encrypting your important files üîëüîê.....Making it unreadable to u üñæüñæüñæ",
                     "Launching Brute-Force-Attack and adding your ip address to botnets!!! üìçüìçüìç",
                     f"Selling your sensitive data to ha*** üé≠ and got a profit worth {x} dollars ü§ë ",
                     f"The dangerous hack has been completed and {member.mention} system has been filled with viruses üíÄüíÄüíÄ!!!"]
            for i in texts:
                await asyncio.sleep(3)
                await my_msg.edit(content=i)

    @commands.command()  # closes the terminal üòÅ:)
    @commands.cooldown(1, 5, commands.BucketType.user)
    async def close(self, ctx):
        '''Used to stop the bot. Only available for developers üòÖ'''
        if ctx.author.id in [768016269269925911, 811919559086702642, 790790711326277652]:
            await ctx.send(f'{ctx.author.mention}You successfully closed the bot!!!')
            await quit()
        # else:
        #     await ctx.reply('This is only for owners üòé!')

    @commands.command(aliases=['i', 'inv'])  # invite link for the bot
    @commands.cooldown(1, 5, commands.BucketType.user)
    async def invite(self, ctx):
        try:
            serverId = ctx.message.guild.id
            allowed = True
            if(allowed == True):
                dbl_invite = Button(style=ButtonStyle.URL, label="DBL invite",
                                    url="https://discordbotlist.com/bots/exploiter")
                top_invite = Button(style=ButtonStyle.URL, label="Top.gg Invite",
                                    url="https://top.gg/bot/839421874646548530")
                server_invite = Button(style=ButtonStyle.URL, label="Join official server",
                                       url="https://top.gg/servers/850200666798161941")
                # await ctx.send("http://tiny.cc/EXPLOITER")
                await ctx.send("You can invite in any one of the link!",
                               components=[
                                   [dbl_invite, top_invite], [server_invite]]
                               )
        except:
            dbl_invite = Button(style=ButtonStyle.URL, label="DBL invite",
                                url="https://discordbotlist.com/bots/exploiter")
            top_invite = Button(style=ButtonStyle.URL, label="Top.gg Invite",
                                url="https://top.gg/bot/839421874646548530")
            server_invite = Button(style=ButtonStyle.URL, label="Join official server",
                                   url="https://top.gg/servers/850200666798161941")
            # await ctx.send("http://tiny.cc/EXPLOITER")
            await ctx.send("You can invite in any one of the link!",
                           components=[
                               [dbl_invite, top_invite], [server_invite]]
                           )

    @commands.command()
    @commands.guild_only()
    @commands.cooldown(1, 20, commands.BucketType.user)
    async def ttt(self, ctx, enemy: discord.Member = None):
        serverId = ctx.message.guild.id

        def winners(available, people_selected):
            wins = [["00", "01", "02"], ["11", "12", "10"], ["20", "21", "22"], ["00", "11", "22"], [
                "02", "11", "20"], ["00", "10", "20"], ["11", "21", "01"], ["02", "12", "22"]]
            flag = 0
            for i in wins:
                if(all(x in people_selected for x in i)):
                    flag = 1
            if flag:
                return 1
            else:
                if len(available) == 0:
                    return 0
                else:
                    return -1
        available = ["00", "01", "02", "10", "11", "12", "20", "21", "22"]
        user_selected = []
        enemy_selected = []

        components = [
            [
                Button(label=" ", style=ButtonStyle.gray, custom_id="00"),
                Button(label=" ", style=ButtonStyle.gray, custom_id="01"),
                Button(label=" ", style=ButtonStyle.gray, custom_id="02")
            ],
            [
                Button(label=" ", style=ButtonStyle.gray, custom_id="10"),
                Button(label=" ", style=ButtonStyle.gray, custom_id="11"),
                Button(label=" ", style=ButtonStyle.gray, custom_id="12")
            ],
            [
                Button(label=" ", style=ButtonStyle.gray, custom_id="20"),
                Button(label=" ", style=ButtonStyle.gray, custom_id="21"),
                Button(label=" ", style=ButtonStyle.gray, custom_id="22")
            ]
        ]
        if enemy == None:
            players = [ctx.author.id, self.bot.user.id]
            last_played = self.bot.user.id
            embed = discord.Embed(title=f"Tic Tac Toe Game {ctx.author.name} vs {self.bot.user.name}",
                                  description=f"{ctx.author.mention} You can start the game ", colour=randint(0, 0xffffff))
            message = await ctx.send(embed=embed, components=components)
            id = message.id
            while True:
                try:
                    interaction = await self.bot.wait_for(
                        'button_click',
                        check=lambda inter: inter.message.id == message.id,
                        timeout=35
                    )
                except asyncio.TimeoutError:
                    embed = discord.Embed(title=f"Tic Tac Toe Game {ctx.author.name} vs {self.bot.user.name}",
                                          description=f"{ctx.author.mention} didn't make up their move on time. So {self.bot.user.mention} won the match ", colour=discord.Color.red())
                    for row in components:
                        row.disable_components()
                    return await message.edit(embed=embed, components=components)
                if interaction.author.id not in players:
                    await interaction.send(f"This game is only for {ctx.author.mention} and {self.bot.user.mention}")
                else:
                    last_played = ctx.author.id
                    selected_id = interaction.custom_id
                    available.remove(selected_id)
                    user_selected.append(selected_id)
                    first = int(selected_id[0])
                    last = int(selected_id[1])
                    components[first][last].label = "X"
                    components[first][last].disabled = True
                    components[first][last].style = ButtonStyle.blue
                    is_win = winners(available, user_selected)
                    if is_win == 0:
                        embed = discord.Embed(
                            title=f"Tic Tac Toe Game {ctx.author.name} vs {self.bot.user.name}", description=f"Match ended up in draw", colour=discord.Color.gold())
                        for row in components:
                            row.disable_components()
                        return await interaction.edit_origin(embed=embed, components=components)
                    elif is_win == 1:
                        embed = discord.Embed(title=f"Tic Tac Toe Game {ctx.author.name} vs {self.bot.user.name}",
                                              description=f"{ctx.author.mention} won the TIC TAC TOE game", colour=discord.Color.green())
                        for row in components:
                            row.disable_components()
                        message = await ctx.fetch_message(id)
                        return await interaction.edit_origin(embed=embed, components=components)
                    message = await ctx.fetch_message(id)
                    embed = message.embeds[0]
                    embed.description = f"Its your move now {self.bot.user.mention}"
                    await interaction.edit_origin(embed=embed, components=components)
                    if len(available) != 0:
                        await asyncio.sleep(3)
                        message = await ctx.fetch_message(id)
                        last_played = self.bot.user.id
                        selected_id = random.choice(available)
                        available.remove(selected_id)
                        enemy_selected.append(selected_id)
                        first = int(selected_id[0])
                        last = int(selected_id[1])
                        components[first][last].label = "O"
                        components[first][last].disabled = True
                        components[first][last].style = ButtonStyle.red
                        is_win = winners(available, enemy_selected)
                        if is_win == 0:
                            embed = discord.Embed(
                                title=f"Tic Tac Toe Game {ctx.author.name} vs {self.bot.user.name}", description=f"Match ended up in draw", colour=discord.Color.gold())
                            for row in components:
                                row.disable_components()
                            return await message.edit(embed=embed, components=components)
                        elif is_win == 1:
                            embed = discord.Embed(title=f"Tic Tac Toe Game {ctx.author.name} vs {self.bot.user.name}",
                                                  description=f"{self.bot.user.mention} won the TIC TAC TOE game", colour=discord.Color.green())
                            for row in components:
                                row.disable_components()
                            return await message.edit(embed=embed, components=components)
                        message = await ctx.fetch_message(id)
                        embed = message.embeds[0]
                        embed.description = f"Its your move now {ctx.author.mention}"
                        await message.edit(embed=embed, components=components)
                    else:
                        embed = discord.Embed(
                            title=f"Tic Tac Toe Game {ctx.author.name} vs {self.bot.user.name}", description=f"Match ended up in draw", colour=discord.Color.gold())
                        for row in components:
                            row.disable_components()
                        return await message.edit(embed=embed, components=components)
        else:
            if ctx.author.id == enemy.id:
                embed = discord.Embed(title="You can't play TTT game  yourself", colour=randint(
                    0, 0xffffff), description="If you wanna play yourself use ``?ttt`` without mentioning anyone")
                await ctx.send(embed=embed)
                return
            elif enemy.bot:
                embed = discord.Embed(title="You can't play TTT game with bot", colour=randint(
                    0, 0xffffff), description="If you wanna play with Exploiter use ``?ttt`` without mentioning anyone")
                await ctx.send(embed=embed)
                return
            components1 = [[Button(label="Agree", style=ButtonStyle.green, custom_id="accept"),
                            Button(label="Decline", style=ButtonStyle.red, custom_id="decline")]]
            embed = discord.Embed(
                description=f"{ctx.author.mention} challenged {enemy.mention} for a TTT game", color=discord.Color.gold())
            message = await ctx.send(embed=embed, components=components1)
            id = message.id
            start = 0
            while start == 0:
                try:
                    interaction = await self.bot.wait_for(
                        'button_click',
                        check=lambda inter: inter.message.id == message.id,
                        timeout=30
                    )
                except asyncio.TimeoutError:
                    for row in components1:
                        row.disable_components()
                    new_embed = discord.Embed(
                        description=f"No response from {enemy.mention}", color=discord.Color.red())
                    return await message.edit(embed=new_embed, components=components1)
                if interaction.custom_id == "accept":
                    if(interaction.author.id == enemy.id):
                        new_embed = discord.Embed(
                            description=f"Alright let's start the TTT game", color=discord.Color.green())
                        start += 1
                        for row in components1:
                            row.disable_components()
                        await interaction.edit_origin(embed=new_embed, components=components1)
                        break
                    else:
                        await interaction.send(f"This is only for {enemy.mention}")
                elif interaction.custom_id == "decline":
                    if(interaction.author.id == enemy.id):
                        new_embed = discord.Embed(
                            description=f"{enemy.mention} cancelled the TTT game as they are not interested", color=discord.Color.red())
                        start += 1
                        for row in components1:
                            row.disable_components()
                        return await interaction.edit_origin(embed=new_embed, components=components1)
                    else:
                        await interaction.send(f"This is only for {enemy.mention}")
            players = [ctx.author.id, enemy.id]
            last_played = enemy.id
            embed = discord.Embed(title=f"Tic Tac Toe Game {ctx.author.name} vs {enemy.name}",
                                  description=f"{ctx.author.mention} You can start the game ", colour=randint(0, 0xffffff))
            message = await ctx.send(embed=embed, components=components)
            id = message.id
            while True:
                try:
                    interaction = await self.bot.wait_for(
                        'button_click',
                        check=lambda inter: inter.message.id == message.id,
                        timeout=30
                    )
                except asyncio.TimeoutError:
                    if last_played == ctx.author.id:
                        embed = discord.Embed(title=f"Tic Tac Toe Game {ctx.author.name} vs {enemy.name}",
                                              description=f"{enemy.mention} didn't make up their move on time. So {ctx.author.mention} won the match", colour=discord.Color.red())
                    else:
                        embed = discord.Embed(title=f"Tic Tac Toe Game {ctx.author.name} vs {enemy.name}",
                                              description=f"{ctx.author.mention} didn't make up their move on time. So {enemy.mention} won the match ", colour=discord.Color.red())
                    for row in components:
                        row.disable_components()
                    return await message.edit(embed=embed, components=components)

                if interaction.author.id not in players:
                    await interaction.send(f"This game is only for {ctx.author.mention} and {enemy.mention}")
                else:
                    if last_played == interaction.author.id:
                        # thing_index=players.index(last_played)
                        if last_played == enemy.id:
                            thing = ctx.author.mention
                        elif last_played == ctx.author.id:
                            thing = enemy.mention
                        await interaction.send(f"Wait for {thing} to make up their move")
                    else:
                        if interaction.author.id == ctx.author.id:
                            last_played = ctx.author.id
                            selected_id = interaction.custom_id
                            available.remove(str(selected_id))
                            user_selected.append(str(selected_id))
                            first = int(selected_id[0])
                            last = int(selected_id[1])
                            components[first][last].label = "X"
                            components[first][last].disabled = True
                            components[first][last].style = ButtonStyle.blue
                            is_win = winners(available, user_selected)
                            if is_win == 0:
                                embed = discord.Embed(
                                    title=f"Tic Tac Toe Game {ctx.author.name} vs {enemy.name}", description=f"Match ended up in draw", colour=discord.Color.gold())
                                for row in components:
                                    row.disable_components()
                                return await interaction.edit_origin(embed=embed, components=components)
                            elif is_win == 1:
                                embed = discord.Embed(title=f"Tic Tac Toe Game {ctx.author.name} vs {enemy.name}",
                                                      description=f"{ctx.author.mention} won the TIC TAC TOE game", colour=discord.Color.green())
                                for row in components:
                                    row.disable_components()
                                return await interaction.edit_origin(embed=embed, components=components)
                            message = await ctx.fetch_message(id)
                            embed = message.embeds[0]
                            embed.description = f"Its your move now {enemy.mention}"
                            await interaction.edit_origin(embed=embed, components=components)
                        else:
                            last_played = enemy.id
                            selected_id = interaction.custom_id
                            available.remove(selected_id)
                            enemy_selected.append(selected_id)
                            first = int(selected_id[0])
                            last = int(selected_id[1])
                            components[first][last].label = "O"
                            components[first][last].disabled = True
                            components[first][last].style = ButtonStyle.red
                            is_win = winners(available, enemy_selected)
                            if is_win == 0:
                                embed = discord.Embed(
                                    title=f"Tic Tac Toe Game {ctx.author.name} vs {enemy.name}", description=f"Match ended up in draw", colour=discord.Color.gold())
                                for row in components:
                                    row.disable_components()
                                return await interaction.edit_origin(embed=embed, components=components)
                            elif is_win == 1:
                                embed = discord.Embed(title=f"Tic Tac Toe Game {ctx.author.name} vs {enemy.name}",
                                                      description=f"{enemy.mention} won the TIC TAC TOE game", colour=discord.Color.green())
                                for row in components:
                                    row.disable_components()
                                return await interaction.edit_origin(embed=embed, components=components)
                            message = await ctx.fetch_message(id)
                            embed = message.embeds[0]
                            embed.description = f"Its your move now {ctx.author.mention}"
                            await interaction.edit_origin(embed=embed, components=components)

    @commands.command(aliases=['hc'])
    @commands.guild_only()
    @commands.cooldown(1, 7, commands.BucketType.user)
    async def hand_cricket(self, ctx, enemy: discord.Member = None):

        if enemy == None:
            components = [
                [
                    Button(label=' ', style=ButtonStyle.blue,
                           emoji="1Ô∏è‚É£", custom_id=1),
                    Button(label=' ', style=ButtonStyle.blue,
                           emoji="2Ô∏è‚É£", custom_id=2),
                    Button(label=' ', style=ButtonStyle.blue, emoji="3Ô∏è‚É£", custom_id=3)],
                [
                    Button(label=' ', style=ButtonStyle.blue,
                           emoji="4Ô∏è‚É£", custom_id=4),
                    Button(label=' ', style=ButtonStyle.blue,
                           emoji="5Ô∏è‚É£", custom_id=5),
                    Button(label=' ', style=ButtonStyle.blue,
                           emoji="6Ô∏è‚É£", custom_id=6)
                ],
                [
                    Button(label="End interaction", style=ButtonStyle.red,
                           emoji="üóëÔ∏è", custom_id="end"),
                    Button(label="Continue", style=ButtonStyle.green,
                           emoji="üîÅ", custom_id="continue", disabled=True),
                    Button(label="Change Batting", style=ButtonStyle.grey,
                           emoji="üí±", custom_id="change", disabled=True)
                ]

            ]
            author = ctx.author
            enemy = self.bot.user
            inviting = False
            first_round = True
            user_value = 0
            enemy_value = 0
            user_balls = 0
            enemy_balls = 0
            user_runs = 0
            enemy_runs = 0
            user_wickets = 0
            enemy_wickets = 0
            players = [ctx.author.id, self.bot.user.id]
            first_round = True
            embed = discord.Embed(title=f"Hand Cricket Match {author.name} vs {enemy.name}",
                                  description=f"It's your move now {author.mention}", colour=randint(0, 0xffffff))
            message = await ctx.send(embed=embed, components=components)
            id = message.id

            def random_batting():
                options = [1, 2, 3, 4, 5, 6]
                return random.choice(options)
            while True:
                try:
                    interaction = await self.bot.wait_for(
                        'button_click',
                        check=lambda inter: inter.message.id == message.id,
                        timeout=35
                    )
                except asyncio.TimeoutError:
                    for row in components:
                        row.disable_components()
                    message = await ctx.fetch_message(id)
                    embed = message.embeds[0]
                    embed.description = f"Match ended due to timeout\n{self.bot.user.mention} won the game as {ctx.author.mention} didn't make up their move in time"
                    embed.color = discord.Color.red()
                    return await message.edit(embed=embed, components=components)
                if interaction.author.id not in players:
                    await interaction.send(f"This game is only for {author.mention} and {enemy.mention}")
                else:
                    if interaction.custom_id == "end":
                        for row in components:
                            row.disable_components()
                        message = await ctx.fetch_message(id)
                        embed = message.embeds[0]
                        embed.description = f"{interaction.author.mention} left the Hand Cricket Match"
                        embed.color = discord.Color.red()
                        return await interaction.edit_origin(embed=embed, components=components)
                    if inviting:
                        if interaction.custom_id == "continue":
                            if ctx.author.id == interaction.author.id:
                                inviting = False
                                new_embed = discord.Embed(
                                    title=f"Hand Cricket Match {author.name} vs {enemy.name}", description=f"Let's start the game {author.mention}.Make your move first", colour=discord.Color.green())
                                for i in range(2):
                                    for j in range(3):
                                        components[i][j].disabled = False
                                components[2][1].disabled = True
                                await interaction.edit_origin(embed=new_embed, components=components)
                                await interaction.send("Alright let's continue the match")
                    else:
                        if first_round == True:
                            interaction_id = int(interaction.custom_id)
                            user_value = interaction_id
                            user_runs += user_value
                            user_balls += 1
                            enemy_value = random_batting()
                            if user_value != enemy_value:
                                embed = discord.Embed(
                                    title=f"Hand Cricket Match {author.name} vs {enemy.name}", description=f"{enemy.mention} also  made their move.So do  your move again {enemy.mention}", colour=randint(0, 0xffffff))
                                embed.add_field(
                                    name="Status", value=f"{author.mention} is batting(Not out)", inline=False)
                                embed.add_field(
                                    name=f"{author.name} statistics", value=f"Balls = {user_balls}\nRuns = {user_runs}\nWickets = {user_wickets}", inline=False)
                                embed.add_field(
                                    name=f"{enemy.name} statistics", value=f"Balls = {enemy_balls}\nRuns = {enemy_runs}\nWickets = {enemy_wickets}", inline=False)
                                embed.add_field(
                                    name="Player moves", value=f"{author.mention} selected {user_value}\n{enemy.mention} selected {enemy_value}")
                                await interaction.edit_origin(embed=embed, components=components)
                            else:
                                user_wickets += 1
                                user_runs = user_runs-user_value
                                embed = discord.Embed(
                                    title=f"Hand Cricket Match {author.name} vs {enemy.name}", description=f"{author.mention} you are out.Select change batting to make opponent bat", colour=randint(0, 0xffffff))
                                embed.add_field(
                                    name="Status", value=f"{author.mention} is batting(Not out)", inline=False)
                                embed.add_field(
                                    name=f"{author.name} statistics", value=f"Balls = {user_balls}\nRuns = {user_runs}\nWickets = {user_wickets}", inline=False)
                                embed.add_field(
                                    name=f"{enemy.name} statistics", value=f"Balls = {enemy_balls}\nRuns = {enemy_runs}\nWickets = {enemy_wickets}", inline=False)
                                embed.add_field(
                                    name="Player moves", value=f"{author.mention} selected {user_value}\n{enemy.mention} selected {enemy_value}")
                                components[0].disable_components()
                                components[1].disable_components()
                                components[2][2].disabled = False
                                first_round = False
                                await interaction.edit_origin(embed=embed, components=components)
                        else:
                            if interaction.custom_id == "change":
                                components[2][2].disabled = True
                                for i in range(2):
                                    for j in range(3):
                                        components[i][j].disabled = False
                                embed = discord.Embed(
                                    title=f"Hand Cricket Match {author.name} vs {enemy.name}", description=f"{enemy.mention} started batting and made their move .Now it's your move {author.mention}", colour=randint(0, 0xffffff))
                                embed.add_field(
                                    name="Status", value=f"{enemy.mention} is batting(Not out)", inline=False)
                                await interaction.edit_origin(embed=embed, components=components)
                            else:
                                enemy_value = random_batting()
                                enemy_runs += enemy_value
                                enemy_balls += 1
                                interaction_id = int(interaction.custom_id)
                                user_value = interaction_id
                                #####################################################
                                if user_value != enemy_value:
                                    embed = discord.Embed(
                                        title=f"Hand Cricket Match {author.name} vs {enemy.name}", description=f"{enemy.mention} also  made their move.So do  your move again {author.mention}", colour=randint(0, 0xffffff))
                                    embed.add_field(
                                        name="Status", value=f"{enemy.mention} is batting(Not out)", inline=False)
                                    embed.add_field(
                                        name=f"{enemy.name} statistics", value=f"Balls = {enemy_balls}\nRuns = {enemy_runs}\nWickets = {enemy_wickets}", inline=False)
                                    embed.add_field(
                                        name=f"{author.name} statistics", value=f"Balls = {user_balls}\nRuns = {user_runs}\nWickets = {user_wickets}", inline=False)
                                    embed.add_field(
                                        name="Player moves", value=f"{author.mention} selected {user_value}\n{enemy.mention} selected {enemy_value}")
                                    await interaction.edit_origin(embed=embed, components=components)
                                else:
                                    enemy_wickets += 1
                                    enemy_runs = enemy_runs-user_value
                                    embed = discord.Embed(
                                        title=f"Hand Cricket Match {author.name} vs {enemy.name}", description=f"It's a wicket {enemy.mention}. Press continue to continue the game!", colour=randint(0, 0xffffff))
                                    embed.add_field(
                                        name="Status", value=f"{enemy.mention} completed batting(wicket)", inline=False)
                                    embed.add_field(
                                        name=f"{enemy.name} statistics", value=f"Balls = {enemy_balls}\nRuns = {enemy_runs}\nWickets = {enemy_wickets}", inline=False)
                                    embed.add_field(
                                        name=f"{author.name} statistics", value=f"Balls = {user_balls}\nRuns = {user_runs}\nWickets = {user_wickets}", inline=False)
                                    embed.add_field(
                                        name="Player moves", value=f"{author.mention} selected {user_value}\n{enemy.mention} selected {enemy_value}")
                                    components[0].disable_components()
                                    components[1].disable_components()
                                    components[2][1].disabled = False
                                    first_round = True
                                    inviting = True
                                    await interaction.edit_origin(embed=embed, components=components)
        else:
            if ctx.author.id == enemy.id:
                embed = discord.Embed(title="You can't play Hand Cricket game  yourself", colour=randint(
                    0, 0xffffff), description="If you wanna play alone use ``?hand_cricket`` without mentioning anyone")
                await ctx.send(embed=embed)
                return
            elif enemy.bot:
                embed = discord.Embed(title="You can't play Hand Cricket game with bots", colour=randint(
                    0, 0xffffff), description="If you wanna play alone or  with Exploiter use ``?hand_cricket`` without mentioning anyone")
                await ctx.send(embed=embed)
                return
            components = [[Button(label="Agree", style=ButtonStyle.green, custom_id="accept"),
                           Button(label="Decline", style=ButtonStyle.red, custom_id="decline")]]
            embed = discord.Embed(
                description=f"{ctx.author.mention} challenged {enemy.mention} for a Hand Cricket match", color=discord.Color.gold())
            message = await ctx.send(embed=embed, components=components)
            id = message.id
            start = 0
            while start == 0:
                try:
                    interaction = await self.bot.wait_for(
                        'button_click',
                        check=lambda inter: inter.message.id == message.id,
                        timeout=30
                    )
                except asyncio.TimeoutError:
                    for row in components:
                        row.disable_components()
                    new_embed = discord.Embed(
                        description=f"No response from {enemy.mention}", color=discord.Color.red())
                    return await message.edit(embed=new_embed, components=components)
                if interaction.custom_id == "accept":
                    if(interaction.author.id == enemy.id):
                        new_embed = discord.Embed(
                            description=f"Alright let's start the Hand Cricket match", color=discord.Color.green())
                        start += 1
                        for row in components:
                            row.disable_components()
                        await interaction.edit_origin(embed=new_embed, components=components)
                        break
                    else:
                        await interaction.send(f"This is only for {enemy.mention}")
                elif interaction.custom_id == "decline":
                    if(interaction.author.id == enemy.id):
                        new_embed = discord.Embed(
                            description=f"{enemy.mention} cancelled the Hand Cricket game as they are not interested", color=discord.Color.red())
                        start += 1
                        for row in components:
                            row.disable_components()
                        return await interaction.edit_origin(embed=new_embed, components=components)
                    else:
                        await interaction.send(f"This is only for {enemy.mention}")

            components = [
                [
                    Button(label=' ', style=ButtonStyle.blue,
                           emoji="1Ô∏è‚É£", custom_id=1),
                    Button(label=' ', style=ButtonStyle.blue,
                           emoji="2Ô∏è‚É£", custom_id=2),
                    Button(label=' ', style=ButtonStyle.blue, emoji="3Ô∏è‚É£", custom_id=3)],
                [
                    Button(label=' ', style=ButtonStyle.blue,
                           emoji="4Ô∏è‚É£", custom_id=4),
                    Button(label=' ', style=ButtonStyle.blue,
                           emoji="5Ô∏è‚É£", custom_id=5),
                    Button(label=' ', style=ButtonStyle.blue,
                           emoji="6Ô∏è‚É£", custom_id=6)
                ],
                [
                    Button(label="End interaction", style=ButtonStyle.red,
                           emoji="üóëÔ∏è", custom_id="end"),
                    Button(label="Continue", style=ButtonStyle.green,
                           emoji="üîÅ", custom_id="continue", disabled=True)
                ]

            ]
            author = ctx.author
            enemy = enemy
            user_accepted = False
            enemy_accepted = False
            user_value = 0
            enemy_value = 0
            user_balls = 0
            enemy_balls = 0
            user_runs = 0
            enemy_runs = 0
            user_wickets = 0
            enemy_wickets = 0
            moved = enemy.id
            players = [ctx.author.id, enemy.id]
            first_round = True
            embed = discord.Embed(title=f"Hand Cricket Match {author.name} vs {enemy.name}",
                                  description=f"It's your move now {author.mention}", colour=randint(0, 0xffffff))
            message = await ctx.send(embed=embed, components=components)
            id = message.id
            inviting = False
            while True:
                try:
                    interaction = await self.bot.wait_for(
                        'button_click',
                        check=lambda inter: inter.message.id == message.id,
                        timeout=30
                    )
                except asyncio.TimeoutError:
                    for row in components:
                        row.disable_components()
                    message = await ctx.fetch_message(id)
                    embed = message.embeds[0]
                    if moved == ctx.author.id:
                        embed.description = f"Match ended due to timeout\n{ctx.author.mention} won the game as {enemy.mention} didn't make up their move in time"
                    else:
                        embed.description = f"Match ended due to timeout\n{enemy.mention} won the game as {ctx.author.mention} didn't make up their move in time"
                    return await message.edit(embed=embed, components=components)

                if interaction.author.id not in players:
                    await interaction.send(f"This game is only for {author.mention} and {enemy.mention}")
                else:
                    if interaction.custom_id == "end":
                        for row in components:
                            row.disable_components()
                        message = await ctx.fetch_message(id)
                        embed = message.embeds[0]
                        embed.description = f"{interaction.author.mention} left the Hand Cricket Match"
                        embed.colour = discord.Color.red()
                        return await interaction.edit_origin(embed=embed, components=components)

                    if inviting:
                        if interaction.custom_id == "continue":

                            if ctx.author.id == interaction.author.id:
                                if user_accepted == True and enemy_accepted == False:
                                    await interaction.send(f"Buddy listen!. You have already clicked continue button.Please wait patiently  for {enemy.mention} to press continue button to continue the game!")
                                else:
                                    user_accepted = True
                                    if user_accepted and enemy_accepted:
                                        pass
                                    else:
                                        await interaction.send(f"Your response has been recorded.Now wait for {enemy.mention} to continue the game!")

                            else:
                                if enemy_accepted == True and user_accepted == False:
                                    await interaction.send(f"Buddy listen!. You have already clicked continue button.Please wait patiently  for {author.mention} to press continue button to continue the game!")
                                else:
                                    enemy_accepted = True
                                    if user_accepted and enemy_accepted:
                                        pass
                                    else:
                                        await interaction.send(f"Your response has been recorded.Now wait for {author.mention} to continue the game!")
                            if user_accepted and enemy_accepted:
                                user_accepted = False
                                inviting = False
                                enemy_accepted = False
                                message = await ctx.fetch_message(id)
                                new_embed = message.embeds[0]
                                new_embed.description = f"Both accepted to continue the game.You can start batting {ctx.author.mention}"
                                new_embed.colour = discord.Color.green()
                                for i in range(2):
                                    for j in range(3):
                                        components[i][j].disabled = False
                                components[2][1].disabled = True
                                await interaction.edit_origin(embed=new_embed, components=components)

                    else:
                        interaction_author = interaction.author.id
                        interaction_id = int(interaction.custom_id)
                        if interaction_author == moved:
                            if interaction_author == author.id:
                                await interaction.send(f"Wait for {enemy.mention} to move!")
                            else:
                                await interaction.send(f"Wait for {author.mention} to move!")
                        else:
                            if first_round:
                                message = await ctx.fetch_message(id)
                                new_embed = message.embeds[0]
                                if author.id == interaction_author:
                                    moved = author.id
                                    user_value = interaction_id
                                    user_runs += interaction_id
                                    status = f"{author.mention} is batting(Not out)"
                                    new_embed.description = f"Its your move now{enemy.mention}"
                                    if len(new_embed.fields) == 0:
                                        new_embed.add_field(
                                            name="Status", value=f"{status}")
                                    await interaction.edit_origin(embed=new_embed)
                                else:
                                    moved = enemy.id
                                    user_balls += 1
                                    enemy_value = interaction_id
                                    new_embed = discord.Embed(
                                        title=f"Hand Cricket Match {author.name} vs {enemy.name}", colour=randint(0, 0xffffff))

                                    if user_value == enemy_value:
                                        moved = author.id
                                        first_round = False
                                        user_wickets += 1
                                        user_runs = user_runs-user_value
                                        status = f"It a wicket! {author.mention}(Wicket)\n{enemy.mention} started batting(Not out)!"
                                    else:
                                        status = f"{author.mention} is batting(Not out)"
                                    user_game_stats = f"Balls = {str(user_balls)}\nRuns = {str(user_runs)}\nWickets = {str(user_wickets)}"
                                    enemy_game_stats = f"Balls = {str(enemy_balls)}\nRuns = {str(enemy_runs)}\nWickets = {str(enemy_wickets)}"
                                    new_embed.add_field(
                                        name="Status", value=f"{status}", inline=False)
                                    new_embed.add_field(
                                        name=f"{author.name} statistics:", value=user_game_stats, inline=False)
                                    new_embed.add_field(
                                        name=f"{enemy.name} statistics", value=enemy_game_stats, inline=False)
                                    new_embed.add_field(
                                        name=f"Player moves:", value=f"{author.mention} selected {str(user_value)}\n{enemy.mention} selected {str(enemy_value)}", inline=False)
                                    if first_round == False:
                                        new_embed.description = f"{author.mention} batting completed. Now it's your batting {enemy.mention} make your move!"
                                    else:
                                        new_embed.description = f"{enemy.mention} made their move.It's your move {author.mention}"
                                    await interaction.edit_origin(embed=new_embed, components=components)
                            else:
                                interaction_author = interaction.author.id
                                interaction_id = int(interaction.custom_id)
                                if enemy.id == interaction_author:
                                    moved = enemy.id
                                    enemy_runs += interaction_id
                                    status = f"{enemy.mention} is batting(Not out)"
                                    new_embed = discord.Embed(
                                        title=f"Hand Cricket Match {author.name} vs {enemy.name}", colour=randint(0, 0xffffff))
                                    new_embed.description = f"{author.mention} made their move. Now it's your move {author.mention}"
                                    new_embed.add_field(
                                        name="Status", value=f"{status}", inline=False)
                                    new_embed.add_field(
                                        name=f"{author.name} statistics:", value=user_game_stats, inline=False)
                                    new_embed.add_field(
                                        name=f"{enemy.name} statistics", value=enemy_game_stats, inline=False)
                                    new_embed.add_field(
                                        name=f"Player moves:", value=f"{author.mention} selected {str(user_value)}\n{enemy.mention} selected {str(enemy_value)}", inline=False)
                                    enemy_value = interaction_id
                                    await interaction.edit_origin(embed=new_embed, components=components)
                                else:
                                    moved = author.id
                                    enemy_balls += 1
                                    user_value = interaction_id
                                    if user_value == enemy_value:
                                        moved = enemy.id
                                        first_round = True
                                        enemy_wickets += 1
                                        enemy_runs = enemy_runs-enemy_value
                                        status = f"It a wicket! {enemy.mention}(Wicket)\n{author.mention} started batting(Not out)!"
                                    else:
                                        status = f"{enemy.mention} is batting(Not out)"
                                    enemy_game_stats = f"Balls = {enemy_balls}\nRuns = {enemy_runs}\nWickets = {enemy_wickets}"
                                    user_game_stats = f"Balls = {user_balls}\nRuns = {user_runs}\nWickets = {user_wickets}"
                                    new_embed = discord.Embed(
                                        title=f"Hand Cricket Match {author.name} vs {enemy.name}", colour=randint(0, 0xffffff))
                                    if user_runs < enemy_runs:
                                        status = f"{enemy.mention} won the game!"
                                        first_round = True
                                    elif first_round:
                                        if user_runs > enemy_runs:
                                            status = f"{author.mention} won the game!"
                                    new_embed.add_field(
                                        name="Status", value=f"{status}", inline=False)
                                    new_embed.add_field(
                                        name=f"{enemy.name} statistics", value=enemy_game_stats, inline=False)
                                    new_embed.add_field(
                                        name=f"{author.name} statistics:", value=user_game_stats, inline=False)
                                    new_embed.add_field(
                                        name=f"Player moves:", value=f"{author.mention} selected {str(user_value)}\n{enemy.mention} selected {str(enemy_value)}", inline=False)

                                    if first_round == True:
                                        new_embed.description = f"{enemy.mention} batting completed. You guys can continue the game by pressing continue button!"
                                        components[0].disable_components()
                                        components[1].disable_components()
                                        components[2][1].disabled = False
                                        inviting = True
                                        await interaction.edit_origin(embed=new_embed, components=components)
                                    else:
                                        new_embed.description = f"Its your move now{enemy.mention}"
                                        await interaction.edit_origin(embed=new_embed, components=components)

    @commands.command()
    @commands.guild_only()
    @commands.cooldown(1, 20, commands.BucketType.user)
    async def rps(self, ctx, enemy: discord.Member = None):
        serverId = ctx.message.guild.id
        allowed = True
        if(allowed == True):
            options_index = [0, 1, 2]
            options = ["Rock :rock:", "Paper üìù", "Scissors ‚úÇÔ∏è"]

            def winner(x, y):
                if(x == y):
                    return 0
                if((x == 0 and y == 2) or (x == 1 and y == 0) or (x == 2 and y == 1)):
                    return 1
                else:
                    return -1
            if(enemy != None):
                if ctx.author.id == enemy.id:
                    embed = discord.Embed(title="You can't play rps game  yourself", colour=randint(
                        0, 0xffffff), description="If you wanna play yourself use ``?rps`` without mentioning anyone")
                    await ctx.send(embed=embed)
                    return
                elif enemy.bot:
                    embed = discord.Embed(title="You can't play rps game with bots", colour=randint(
                        0, 0xffffff), description="If you wanna play with Exploiter use ``?rps`` without mentioning anyone")
                    await ctx.send(embed=embed)
                    return
                components = [[Button(label="Agree", style=ButtonStyle.green, custom_id="accept"),
                               Button(label="Decline", style=ButtonStyle.red, custom_id="decline")]]
                embed = discord.Embed(
                    description=f"{ctx.author.mention} challenged {enemy.mention} for a RPS game", color=discord.Color.gold())
                message = await ctx.send(embed=embed, components=components)
                id = message.id
                start = 0
                while start == 0:
                    try:
                        interaction = await self.bot.wait_for(
                            'button_click',
                            check=lambda inter: inter.message.id == message.id,
                            timeout=30
                        )
                    except asyncio.TimeoutError:
                        for row in components:
                            row.disable_components()
                        new_embed = discord.Embed(
                            description=f"No response from {enemy.mention}", color=discord.Color.red())
                        return await message.edit(embed=new_embed, components=components)
                    if interaction.custom_id == "accept":
                        if(interaction.author.id == enemy.id):
                            new_embed = discord.Embed(
                                description=f"Alright let's start the RPS game", color=discord.Color.green())
                            start += 1
                            for row in components:
                                row.disable_components()
                            await interaction.edit_origin(embed=new_embed, components=components)
                            break
                        else:
                            await interaction.send(f"This is only for {enemy.mention}")
                    elif interaction.custom_id == "decline":
                        if(interaction.author.id == enemy.id):
                            new_embed = discord.Embed(
                                description=f"{enemy.mention} cancelled the rps game as they are not interested", color=discord.Color.red())
                            start += 1
                            for row in components:
                                row.disable_components()
                            return await interaction.edit_origin(embed=new_embed, components=components)
                        else:
                            await interaction.send(f"This is only for {enemy.mention}")

            components = [
                [
                    Button(label='Stone', style=ButtonStyle.blue,
                           custom_id='st', emoji="ü™®"),
                    Button(label='Paper', style=ButtonStyle.blue,
                           custom_id='pa', emoji="üìù"),
                    Button(label='Scissors', style=ButtonStyle.blue,
                           custom_id='sc', emoji="‚úÇÔ∏è")

                ],
                [Button(label='End interaction', style=ButtonStyle.red,
                        custom_id='end', emoji="üóëÔ∏è")]
            ]

            if(enemy == None):
                total_played = 0
                draws = 0
                user_wins = 0
                exp_wins = 0
                embed = discord.Embed(title=f"Rock Paper Scissors game {ctx.author.name} vs EXPLOITER",
                                      description="Click on the button to choose what you want!", colour=randint(0, 0xffffff))
                message = await ctx.send(embed=embed, components=components)
                id = message.id
                while True:
                    try:
                        interaction = await self.bot.wait_for(
                            'button_click',
                            check=lambda inter: inter.message.id == message.id,
                            timeout=20
                        )
                    except asyncio.TimeoutError:
                        for row in components:
                            row.disable_components()
                        return await message.edit(components=components)
                    if interaction.author.id == ctx.author.id:
                        bot_move_index = random.choice(options_index)
                        bot_move = options[bot_move_index]
                        if interaction.custom_id == "st":
                            user = options[0]
                            user_index = 0
                        elif interaction.custom_id == "pa":
                            user = options[1]
                            user_index = 1
                        elif interaction.custom_id == "sc":
                            user = options[2]
                            user_index = 2
                        else:
                            for row in components:
                                row.disable_components()
                            message = await ctx.fetch_message(id)
                            return await interaction.edit_origin(embed=message.embeds[0], components=components)
                        x = winner(user_index, bot_move_index)
                        if(x == 0):
                            draws += 1
                            total_played += 1
                            string = "Match ended in draw as both kept same thing"
                        elif(x == 1):
                            user_wins += 1
                            total_played += 1
                            string = f"{interaction.author.mention} won the match"
                        else:
                            exp_wins += 1
                            total_played += 1
                            string = f"{self.bot.user.mention} won the match"
                        new_embed = discord.Embed(
                            title="RPS", description=f"{interaction.author.mention} choosed {user}\n {self.bot.user.mention} choosed {bot_move}", colour=randint(0, 0xffffff))
                        new_embed.add_field(
                            name='Status of Game', value=f"{string}", inline=False)
                        new_embed.add_field(
                            name="Game Stats:", value=f"{ctx.author.mention} wins = {str(user_wins)}\n{self.bot.user.mention} wins = {str(exp_wins)}\n Draws = {str(draws)}\n Total Matches Played = {str(total_played)}")
                        await interaction.edit_origin(embed=new_embed, components=components)

                    else:
                        await interaction.send(f'This game is not for you!')
            else:
                embed = discord.Embed(title=f"Rock Paper Scissors {ctx.author.name} vs {enemy.name}",
                                      description=f"Click on the button to choose what you want!\nIt's your move first {ctx.author.mention}", colour=randint(0, 0xffffff))
                message = await ctx.send(embed=embed, components=components)
                id = message.id
                full = []
                user_win = 0
                member_win = 0
                total_played = 0
                draws = 0
                players = [ctx.author.id, enemy.id]
                last_played = enemy.id
                while True:
                    try:
                        interaction = await self.bot.wait_for(
                            'button_click',
                            check=lambda inter: inter.message.id == message.id,
                            timeout=20
                        )
                    except asyncio.TimeoutError:
                        for row in components:
                            row.disable_components()
                        message = await ctx.fetch_message(id)
                        embed = message.embeds[0]
                        if last_played == ctx.author.id:
                            user_win += 1
                            embed.set_footer(
                                text=f"{ctx.author.name} won the game as {enemy.name} didn't make their move in time")
                        else:
                            member_win += 1
                            embed.set_footer(
                                text=f"{enemy.name} won the game as {ctx.author.name} didn't make their move in time")
                        return await message.edit(embed=embed, components=components)
                    if interaction.author.id in players:
                        if(interaction.custom_id == "end"):
                            for row in components:
                                row.disable_components()
                            message = await ctx.fetch_message(id)
                            embed = message.embeds[0]
                            embed.set_footer(
                                text=f"{interaction.author.name} left the game")
                            await interaction.edit_origin(embed=embed, components=components)
                            return
                        if last_played != interaction.author.id:
                            last_played = interaction.author.id
                            if(len(full) == 0):
                                if interaction.custom_id == "st":
                                    user = options[0]
                                    user_index = 0
                                elif interaction.custom_id == "pa":
                                    user = options[1]
                                    user_index = 1
                                elif interaction.custom_id == "sc":
                                    user = options[2]
                                    user_index = 2
                                full.append(interaction.author.id)
                                message = await ctx.fetch_message(id)
                                embed = message.embeds[0]
                                embed.description = f"Click on the button to choose what you want!\nIt's your move now {enemy.mention}"
                                await interaction.edit_origin(embed=embed, components=components)
                                await interaction.send(f"You selected {user}. Wait for {enemy.mention} move")
                            elif(len(full) == 1):
                                ###########################
                                if interaction.custom_id == "st":
                                    member = options[0]
                                    member_index = 0
                                elif interaction.custom_id == "pa":
                                    member = options[1]
                                    member_index = 1
                                elif interaction.custom_id == "sc":
                                    member = options[2]
                                    member_index = 2
                                full.append(interaction.author.id)
                                full = []
                                new_embed = discord.Embed(title=f"RPS game {ctx.author.name} VS {interaction.author.name}",
                                                          description=f"{ctx.author.mention} choosed {user}\n{interaction.author.mention} choosed {member}", colour=randint(0, 0xffffff))
                                selector = winner(user_index, member_index)
                                if selector == 1:
                                    user_win += 1
                                    total_played += 1
                                    string = f"{ctx.author.mention} won the game"
                                elif selector == -1:
                                    member_win += 1
                                    total_played += 1
                                    string = f"{interaction.author.mention} won the game"
                                else:
                                    draws += 1
                                    total_played += 1
                                    string = f"Match ended in draw"
                                new_embed.add_field(
                                    name="Status of game", value=f"{string}")
                                new_embed.add_field(
                                    name="Total Winnings", value=f"{ctx.author.mention} wins = {str(user_win)} \n{interaction.author.mention} wins = {str(member_win)}\n Draws = {str(draws)}\n Total Mtaches Played = {str(total_played)}", inline=False)
                                await interaction.edit_origin(embed=new_embed, components=components)
                        else:
                            if(last_played == ctx.author.id):
                                await interaction.send(f"Wait for {enemy.mention} move")
                            else:
                                await interaction.send(f"Wait for {ctx.author.mention} move")

                    else:
                        await interaction.send(f'This game is only for {ctx.author.mention} and {enemy.mention} and it is not for you!')

    @commands.command(aliases=['v', 'vt'])  # invite link for the bot
    @commands.cooldown(1, 5, commands.BucketType.user)
    async def vote(self, ctx):
        try:
            serverId = ctx.message.guild.id
            allowed = True
            if(allowed == True):
                dbl_vote = Button(style=ButtonStyle.URL, label="DBL vote",
                                  url="https://discordbotlist.com/bots/exploiter/upvote")
                top_vote = Button(style=ButtonStyle.URL, label="Top.gg vote",
                                  url="https://top.gg/bot/839421874646548530/vote")
                server_invite = Button(style=ButtonStyle.URL, label="Join official server",
                                       url="https://top.gg/servers/850200666798161941")
                # await ctx.send("http://tiny.cc/EXPLOITER")
                await ctx.send("You can vote in any link!",
                               components=[
                                   [dbl_vote, top_vote], [server_invite]]
                               )
        except:
            dbl_vote = Button(style=ButtonStyle.URL, label="DBL vote",
                              url="https://discordbotlist.com/bots/exploiter/upvote")
            top_vote = Button(style=ButtonStyle.URL, label="Top.gg vote",
                              url="https://top.gg/bot/839421874646548530/vote")
            server_invite = Button(style=ButtonStyle.URL, label="Join official server",
                                   url="https://top.gg/servers/850200666798161941")
            # await ctx.send("http://tiny.cc/EXPLOITER")
            await ctx.send("You can invite in any link!",
                           components=[[dbl_vote, top_vote], [server_invite]]
                           )

    @commands.command(aliases=['q', 'qte'])
    @commands.guild_only()
    @commands.cooldown(1, 3, commands.BucketType.user)
    async def quote(self, ctx: commands.context, day: str = None):
        serverId = ctx.message.guild.id
        allowed = True
        if(allowed == True):
            if(day == None):
                response = requests.get("https://zenquotes.io/api/random")
                zen = (response.json())
                await ctx.reply(zen[0]['q']+"\n                                          \t\t\t-"+zen[0]['a'])
            elif(day == "today"):
                response = requests.get("https://zenquotes.io/api/today")
                zen = response.json()
                await ctx.reply(zen[0]['q']+"\n                                          \t\t\t-"+zen[0]['a'])
            else:
                await ctx.reply("``?quote`` to get random quote and ``?quote today`` to get today's quote")


def setup(bot):
    # asyncio.sleep(1)
    bot.add_cog(funs(bot))
    print(f'Fun was loaded!')
